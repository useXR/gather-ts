================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2025-02-07T17:38:32.779Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.deppack/token-cache.json
.gitignore
.npmignore
.npmrc
.prettierignore
CONTRIBUTING.md
eslint.config.mjs
jest.config.ts
LICENSE
madge.config.js
package.json
README.md
src/__tests__/index.test.ts
src/cli.ts
src/config/ConfigManager.ts
src/config/index.ts
src/config/interfaces/IConfigManager.ts
src/config/validators/ConfigValidator.ts
src/container/Container.ts
src/container/ContainerConfig.ts
src/container/interfaces/IContainer.ts
src/core/compiler/ArgumentParser.ts
src/core/compiler/CompileContext.ts
src/core/compiler/index.ts
src/core/compiler/interfaces/IArgumentParser.ts
src/core/compiler/interfaces/ICompileContext.ts
src/core/dependency/DependencyAnalyzer.ts
src/core/dependency/DependencyCache.ts
src/core/dependency/IgnoreHandler.ts
src/core/dependency/index.ts
src/core/dependency/interfaces/IDependencyAnalyzer.ts
src/core/dependency/interfaces/IDependencyCache.ts
src/core/dependency/interfaces/IIgnoreHandler.ts
src/core/templating/DefaultTemplates.ts
src/core/templating/index.ts
src/core/templating/interfaces/ITemplateManager.ts
src/core/templating/TemplateManager.ts
src/core/tokenization/index.ts
src/core/tokenization/interfaces/ITokenCache.ts
src/core/tokenization/interfaces/ITokenCounter.ts
src/core/tokenization/TokenCache.ts
src/core/tokenization/TokenCounter.ts
src/errors/exceptions/index.ts
src/errors/handlers/ErrorHandler.ts
src/errors/index.ts
src/errors/interfaces/error-types.ts
src/errors/interfaces/IError.ts
src/errors/interfaces/IErrorHandler.ts
src/errors/interfaces/IErrorUtils.ts
src/errors/utils/ErrorUtils.ts
src/index.ts
src/interfaces/cli.ts
src/register.ts
src/types/common.ts
src/types/compiler.ts
src/types/config.ts
src/types/dependency.ts
src/types/errors.ts
src/types/events.ts
src/types/files.ts
src/types/index.ts
src/types/models/tokenizer.ts
src/types/services.ts
src/types/stats.ts
src/utils/filesystem/FileSystem.ts
src/utils/filesystem/index.ts
src/utils/filesystem/interfaces/IFileSystem.ts
src/utils/index.ts
src/utils/logging/index.ts
src/utils/logging/interfaces/ILogger.ts
src/utils/logging/Logger.ts
src/utils/validation/index.ts
src/utils/validation/interfaces/IValidator.ts
src/utils/validation/Validator.ts
tsconfig.json
typedoc.json

================================================================
Repository Files
================================================================

================
File: .deppack/token-cache.json
================
{
  "src\\app\\admin\\dashboard\\page.tsx": {
    "hash": "1bcdca8e4c197b0efcecbf2c8b68497e",
    "tokens": 235,
    "lastUpdated": "2025-02-05T19:23:36.679Z"
  },
  "src\\components\\admin\\admin-content.tsx": {
    "hash": "1ea6360235cb4f38e378793d8d7250ef",
    "tokens": 1597,
    "lastUpdated": "2025-02-05T19:23:36.686Z"
  },
  "src\\components\\admin\\admin-dashboard.tsx": {
    "hash": "d1545530fd46d0072818e9a3efc92cbd",
    "tokens": 828,
    "lastUpdated": "2025-02-05T19:23:36.696Z"
  },
  "src\\components\\admin\\audit-log-viewer.tsx": {
    "hash": "141a9ae0ac22fb9ecf716a9843dfe78c",
    "tokens": 1431,
    "lastUpdated": "2025-02-05T19:23:36.704Z"
  },
  "src\\components\\admin\\permission-groups.tsx": {
    "hash": "439dfec946b244eb609648ba4482e12c",
    "tokens": 5761,
    "lastUpdated": "2025-02-05T19:23:36.717Z"
  },
  "src\\components\\admin\\permission-matrix.tsx": {
    "hash": "1ecf41bd40ff39b22de28d07ecdd896a",
    "tokens": 1722,
    "lastUpdated": "2025-02-05T19:23:36.720Z"
  },
  "src\\components\\admin\\role-management.tsx": {
    "hash": "f95eb8c85a725ef779ec9f42c041805c",
    "tokens": 1857,
    "lastUpdated": "2025-02-05T19:23:36.753Z"
  },
  "src\\components\\admin\\user-management.tsx": {
    "hash": "18ed2352acbba4f2c8c7aa63cf4d9e1f",
    "tokens": 1791,
    "lastUpdated": "2025-02-05T19:23:36.832Z"
  },
  "src\\components\\common\\conditional-content.tsx": {
    "hash": "da32a57b31869dd0ca8baccc1870c563",
    "tokens": 321,
    "lastUpdated": "2025-02-05T19:23:36.911Z"
  },
  "src\\components\\common\\loading.tsx": {
    "hash": "039c9c3c5d99905417d7ccf14bb5b302",
    "tokens": 272,
    "lastUpdated": "2025-02-05T19:23:37.013Z"
  },
  "src\\env.ts": {
    "hash": "d7a02ee3fa650c24675749300a6925ca",
    "tokens": 347,
    "lastUpdated": "2025-02-05T19:23:37.119Z"
  },
  "src\\hooks\\use-auth.ts": {
    "hash": "43209e24124d468434473462ce89ef7e",
    "tokens": 913,
    "lastUpdated": "2025-02-05T19:23:37.238Z"
  },
  "src\\hooks\\use-toast.ts": {
    "hash": "23f3f1928207fb53866873df6c6d93dd",
    "tokens": 1044,
    "lastUpdated": "2025-02-05T19:23:37.342Z"
  },
  "src\\lib\\schema\\models\\action.model.ts": {
    "hash": "e3780b266da61f9567bc1217b2234fa4",
    "tokens": 339,
    "lastUpdated": "2025-02-05T19:23:37.412Z"
  },
  "src\\lib\\schema\\models\\feature.model.ts": {
    "hash": "4a70e57ca2dcd9c45a180049b25470a6",
    "tokens": 339,
    "lastUpdated": "2025-02-05T19:23:37.507Z"
  },
  "src\\lib\\schema\\models\\permission.model.ts": {
    "hash": "580166d0ba409aab997dfd868dced0b9",
    "tokens": 348,
    "lastUpdated": "2025-02-05T19:23:37.604Z"
  },
  "src\\lib\\schema\\models\\role-audit-log.model.ts": {
    "hash": "09dcddf771dda2375db6f5354d7ed216",
    "tokens": 407,
    "lastUpdated": "2025-02-05T19:23:37.710Z"
  },
  "src\\lib\\schema\\models\\role.model.ts": {
    "hash": "d43228d0d5963a43a8c67833154558fe",
    "tokens": 339,
    "lastUpdated": "2025-02-05T19:23:37.817Z"
  },
  "src\\lib\\schema\\models\\user-profile.model.ts": {
    "hash": "9a43d2ddd97f33b59d8222cc444537f8",
    "tokens": 411,
    "lastUpdated": "2025-02-05T19:23:37.917Z"
  },
  "src\\server\\api\\root.ts": {
    "hash": "9d3853ccbf6c68ff9ca09a547705d971",
    "tokens": 274,
    "lastUpdated": "2025-02-05T19:23:38.033Z"
  },
  "src\\server\\api\\routers\\action.ts": {
    "hash": "8af4b37a9f21a36a932b22035df6f1bf",
    "tokens": 787,
    "lastUpdated": "2025-02-05T19:23:38.137Z"
  },
  "src\\server\\api\\routers\\feature.ts": {
    "hash": "04a642f6a16d8b0c9db63bba2aa26182",
    "tokens": 962,
    "lastUpdated": "2025-02-05T19:23:38.257Z"
  },
  "src\\server\\api\\routers\\permission-group.ts": {
    "hash": "72247c861d5052c4567857506c3b863b",
    "tokens": 2725,
    "lastUpdated": "2025-02-05T19:23:38.366Z"
  },
  "src\\server\\api\\routers\\permission-override.ts": {
    "hash": "de55ad22caef782ccf95184af108c5c3",
    "tokens": 1870,
    "lastUpdated": "2025-02-05T19:23:38.472Z"
  },
  "src\\server\\api\\routers\\permission.ts": {
    "hash": "3064b3b8e736c7d7cebb78a1d2a03ca8",
    "tokens": 1742,
    "lastUpdated": "2025-02-05T19:23:38.577Z"
  },
  "src\\server\\api\\routers\\role.ts": {
    "hash": "fbc1e7f7bbef543a6571223557680ec9",
    "tokens": 2575,
    "lastUpdated": "2025-02-05T19:23:38.697Z"
  },
  "src\\server\\api\\routers\\types.ts": {
    "hash": "b62439daa3ed59f8748330f113587b5a",
    "tokens": 246,
    "lastUpdated": "2025-02-05T19:23:38.771Z"
  },
  "src\\server\\api\\routers\\user.ts": {
    "hash": "528f96c98522200449f8e0d9894f2fd6",
    "tokens": 1494,
    "lastUpdated": "2025-02-05T19:23:38.905Z"
  },
  "src\\server\\api\\trpc.ts": {
    "hash": "038f3afe820488727b0313309a5339ec",
    "tokens": 1584,
    "lastUpdated": "2025-02-05T19:23:39.014Z"
  },
  "src\\server\\db.ts": {
    "hash": "32532ad7624a1d810507b894c3d4d957",
    "tokens": 119,
    "lastUpdated": "2025-02-05T19:23:39.151Z"
  },
  "src\\trpc\\query-client.ts": {
    "hash": "a4227a353e0d6f50c64a194e2ee5f774",
    "tokens": 170,
    "lastUpdated": "2025-02-05T19:23:39.249Z"
  },
  "src\\trpc\\react.tsx": {
    "hash": "a31e35aee166bf164647631f0d3220e9",
    "tokens": 531,
    "lastUpdated": "2025-02-05T19:23:39.344Z"
  },
  "src\\trpc\\shared.ts": {
    "hash": "7599a49e5091aef97ad0abfdefe35378",
    "tokens": 215,
    "lastUpdated": "2025-02-05T19:23:39.455Z"
  },
  "src\\utils\\supabase\\client.ts": {
    "hash": "4bf64f6cf9ca6e52cb930e6b49623b7e",
    "tokens": 47,
    "lastUpdated": "2025-02-05T19:23:39.567Z"
  },
  "src\\utils\\supabase\\server.ts": {
    "hash": "383b4aa97539ec665d9794c2cb3f7c76",
    "tokens": 173,
    "lastUpdated": "2025-02-05T19:23:39.674Z"
  },
  "..\\nextjs-supabase-starter\\src\\app\\admin\\dashboard\\page.tsx": {
    "hash": "1bcdca8e4c197b0efcecbf2c8b68497e",
    "tokens": 235,
    "lastUpdated": "2025-02-07T00:54:03.948Z"
  },
  "..\\nextjs-supabase-starter\\src\\app\\api\\trpc\\[trpc]\\route.ts": {
    "hash": "ef8c88077df38831424727380152d68d",
    "tokens": 234,
    "lastUpdated": "2025-02-07T00:54:03.951Z"
  },
  "..\\nextjs-supabase-starter\\src\\components\\admin\\admin-dashboard.tsx": {
    "hash": "d1545530fd46d0072818e9a3efc92cbd",
    "tokens": 828,
    "lastUpdated": "2025-02-07T00:54:03.954Z"
  },
  "..\\nextjs-supabase-starter\\src\\components\\common\\loading.tsx": {
    "hash": "039c9c3c5d99905417d7ccf14bb5b302",
    "tokens": 272,
    "lastUpdated": "2025-02-07T00:54:03.956Z"
  },
  "..\\nextjs-supabase-starter\\src\\hooks\\use-auth.ts": {
    "hash": "43209e24124d468434473462ce89ef7e",
    "tokens": 913,
    "lastUpdated": "2025-02-07T00:54:03.960Z"
  },
  "..\\nextjs-supabase-starter\\src\\env.ts": {
    "hash": "d7a02ee3fa650c24675749300a6925ca",
    "tokens": 347,
    "lastUpdated": "2025-02-07T00:54:03.962Z"
  },
  "..\\nextjs-supabase-starter\\src\\server\\api\\root.ts": {
    "hash": "9d3853ccbf6c68ff9ca09a547705d971",
    "tokens": 274,
    "lastUpdated": "2025-02-07T00:54:03.963Z"
  },
  "..\\nextjs-supabase-starter\\src\\server\\api\\trpc.ts": {
    "hash": "038f3afe820488727b0313309a5339ec",
    "tokens": 1584,
    "lastUpdated": "2025-02-07T00:54:03.967Z"
  },
  "..\\nextjs-supabase-starter\\src\\components\\admin\\admin-content.tsx": {
    "hash": "1ea6360235cb4f38e378793d8d7250ef",
    "tokens": 1597,
    "lastUpdated": "2025-02-07T00:54:03.970Z"
  },
  "..\\nextjs-supabase-starter\\src\\components\\common\\conditional-content.tsx": {
    "hash": "da32a57b31869dd0ca8baccc1870c563",
    "tokens": 321,
    "lastUpdated": "2025-02-07T00:54:03.972Z"
  },
  "..\\nextjs-supabase-starter\\src\\lib\\schema\\models\\action.model.ts": {
    "hash": "e3780b266da61f9567bc1217b2234fa4",
    "tokens": 339,
    "lastUpdated": "2025-02-07T00:54:03.974Z"
  },
  "..\\nextjs-supabase-starter\\src\\lib\\schema\\models\\feature.model.ts": {
    "hash": "4a70e57ca2dcd9c45a180049b25470a6",
    "tokens": 339,
    "lastUpdated": "2025-02-07T00:54:03.975Z"
  },
  "..\\nextjs-supabase-starter\\src\\lib\\schema\\models\\permission.model.ts": {
    "hash": "580166d0ba409aab997dfd868dced0b9",
    "tokens": 348,
    "lastUpdated": "2025-02-07T00:54:03.977Z"
  },
  "..\\nextjs-supabase-starter\\src\\lib\\schema\\models\\role.model.ts": {
    "hash": "d43228d0d5963a43a8c67833154558fe",
    "tokens": 339,
    "lastUpdated": "2025-02-07T00:54:03.978Z"
  },
  "..\\nextjs-supabase-starter\\src\\lib\\schema\\models\\user-profile.model.ts": {
    "hash": "9a43d2ddd97f33b59d8222cc444537f8",
    "tokens": 411,
    "lastUpdated": "2025-02-07T00:54:03.979Z"
  },
  "..\\nextjs-supabase-starter\\src\\trpc\\react.tsx": {
    "hash": "a31e35aee166bf164647631f0d3220e9",
    "tokens": 531,
    "lastUpdated": "2025-02-07T00:54:03.981Z"
  },
  "..\\nextjs-supabase-starter\\src\\utils\\supabase\\client.ts": {
    "hash": "4bf64f6cf9ca6e52cb930e6b49623b7e",
    "tokens": 47,
    "lastUpdated": "2025-02-07T00:54:03.982Z"
  },
  "..\\nextjs-supabase-starter\\src\\server\\api\\routers\\action.ts": {
    "hash": "8af4b37a9f21a36a932b22035df6f1bf",
    "tokens": 787,
    "lastUpdated": "2025-02-07T00:54:03.984Z"
  },
  "..\\nextjs-supabase-starter\\src\\server\\api\\routers\\feature.ts": {
    "hash": "04a642f6a16d8b0c9db63bba2aa26182",
    "tokens": 962,
    "lastUpdated": "2025-02-07T00:54:03.987Z"
  },
  "..\\nextjs-supabase-starter\\src\\server\\api\\routers\\permission-group.ts": {
    "hash": "72247c861d5052c4567857506c3b863b",
    "tokens": 2725,
    "lastUpdated": "2025-02-07T00:54:03.992Z"
  },
  "..\\nextjs-supabase-starter\\src\\server\\api\\routers\\permission-override.ts": {
    "hash": "de55ad22caef782ccf95184af108c5c3",
    "tokens": 1870,
    "lastUpdated": "2025-02-07T00:54:03.996Z"
  },
  "..\\nextjs-supabase-starter\\src\\server\\api\\routers\\permission.ts": {
    "hash": "3064b3b8e736c7d7cebb78a1d2a03ca8",
    "tokens": 1742,
    "lastUpdated": "2025-02-07T00:54:04.000Z"
  },
  "..\\nextjs-supabase-starter\\src\\server\\api\\routers\\role.ts": {
    "hash": "fbc1e7f7bbef543a6571223557680ec9",
    "tokens": 2575,
    "lastUpdated": "2025-02-07T00:54:04.005Z"
  },
  "..\\nextjs-supabase-starter\\src\\server\\api\\routers\\user.ts": {
    "hash": "528f96c98522200449f8e0d9894f2fd6",
    "tokens": 1494,
    "lastUpdated": "2025-02-07T00:54:04.009Z"
  },
  "..\\nextjs-supabase-starter\\src\\server\\db.ts": {
    "hash": "32532ad7624a1d810507b894c3d4d957",
    "tokens": 119,
    "lastUpdated": "2025-02-07T00:54:04.011Z"
  },
  "..\\nextjs-supabase-starter\\src\\utils\\supabase\\server.ts": {
    "hash": "383b4aa97539ec665d9794c2cb3f7c76",
    "tokens": 173,
    "lastUpdated": "2025-02-07T00:54:04.012Z"
  },
  "..\\nextjs-supabase-starter\\src\\components\\admin\\audit-log-viewer.tsx": {
    "hash": "141a9ae0ac22fb9ecf716a9843dfe78c",
    "tokens": 1431,
    "lastUpdated": "2025-02-07T00:54:04.015Z"
  },
  "..\\nextjs-supabase-starter\\src\\components\\admin\\permission-groups.tsx": {
    "hash": "439dfec946b244eb609648ba4482e12c",
    "tokens": 5761,
    "lastUpdated": "2025-02-07T00:54:04.025Z"
  },
  "..\\nextjs-supabase-starter\\src\\components\\admin\\permission-matrix.tsx": {
    "hash": "1ecf41bd40ff39b22de28d07ecdd896a",
    "tokens": 1722,
    "lastUpdated": "2025-02-07T00:54:04.029Z"
  },
  "..\\nextjs-supabase-starter\\src\\components\\admin\\role-management.tsx": {
    "hash": "f95eb8c85a725ef779ec9f42c041805c",
    "tokens": 1857,
    "lastUpdated": "2025-02-07T00:54:04.033Z"
  },
  "..\\nextjs-supabase-starter\\src\\components\\admin\\user-management.tsx": {
    "hash": "18ed2352acbba4f2c8c7aa63cf4d9e1f",
    "tokens": 1791,
    "lastUpdated": "2025-02-07T00:54:04.036Z"
  },
  "..\\nextjs-supabase-starter\\src\\trpc\\query-client.ts": {
    "hash": "a4227a353e0d6f50c64a194e2ee5f774",
    "tokens": 170,
    "lastUpdated": "2025-02-07T00:54:04.038Z"
  },
  "..\\nextjs-supabase-starter\\src\\server\\api\\routers\\types.ts": {
    "hash": "b62439daa3ed59f8748330f113587b5a",
    "tokens": 246,
    "lastUpdated": "2025-02-07T00:54:04.039Z"
  },
  "..\\nextjs-supabase-starter\\src\\trpc\\shared.ts": {
    "hash": "7599a49e5091aef97ad0abfdefe35378",
    "tokens": 215,
    "lastUpdated": "2025-02-07T00:54:04.041Z"
  },
  "..\\nextjs-supabase-starter\\src\\lib\\schema\\models\\role-audit-log.model.ts": {
    "hash": "09dcddf771dda2375db6f5354d7ed216",
    "tokens": 407,
    "lastUpdated": "2025-02-07T00:54:04.042Z"
  },
  "..\\nextjs-supabase-starter\\src\\hooks\\use-toast.ts": {
    "hash": "23f3f1928207fb53866873df6c6d93dd",
    "tokens": 1044,
    "lastUpdated": "2025-02-07T00:54:04.045Z"
  },
  "..\\nextjs-supabase-starter\\README.md": {
    "hash": "60629000afbb9b754d862f14ae64bffc",
    "tokens": 962,
    "lastUpdated": "2025-02-07T00:54:04.047Z"
  },
  "..\\nextjs-supabase-starter\\package.json": {
    "hash": "8a7c8eb0b600116c67a67960a05cd7a5",
    "tokens": 1043,
    "lastUpdated": "2025-02-07T00:54:04.049Z"
  }
}

================
File: .gitignore
================
.gather-ts
node_modules
dist
.gather-ts-ignore
gather-ts.config.json
repomix-output.txt

================
File: .npmignore
================
# Development files
src/
tests/
docs/
.github/
.vscode/
coverage/
*.test.ts
*.spec.ts

# Configuration files
.eslintrc.js
.prettierrc.js
jest.config.ts
tsconfig.json
typedoc.json

# Build artifacts
*.tsbuildinfo
.nyc_output/

# Development tools
.editorconfig
.gitattributes
CONTRIBUTING.md

================
File: .npmrc
================
package-lock=true
save-exact=true

================
File: .prettierignore
================
# .prettierignore
dist/
coverage/
docs/
node_modules/
*.md
*.json
!package.json
!tsconfig.json
!typedoc.json

================
File: CONTRIBUTING.md
================
# Contributing to gather-ts

We love your input! We want to make contributing to gather-ts as easy and transparent as possible, whether it's:

- Reporting a bug
- Discussing the current state of the code
- Submitting a fix
- Proposing new features
- Becoming a maintainer

## We Develop with Github
We use GitHub to host code, to track issues and feature requests, as well as accept pull requests.

## Pull Requests Process

1. Fork the repo and create your branch from `main`.
2. If you've added code that should be tested, add tests.
3. If you've changed APIs, update the documentation.
4. Ensure the test suite passes.
5. Make sure your code lints.
6. Issue that pull request!

## Any contributions you make will be under the MIT Software License
In short, when you submit code changes, your submissions are understood to be under the same [MIT License](http://choosealicense.com/licenses/mit/) that covers the project. Feel free to contact the maintainers if that's a concern.

## Report bugs using Github's [issue tracker](https://github.com/usexr/gather-ts/issues)
We use GitHub issues to track public bugs. Report a bug by [opening a new issue](https://github.com/usexr/gather-ts/issues/new); it's that easy!

## Write bug reports with detail, background, and sample code

**Great Bug Reports** tend to have:

- A quick summary and/or background
- Steps to reproduce
  - Be specific!
  - Give sample code if you can.
- What you expected would happen
- What actually happens
- Notes (possibly including why you think this might be happening, or stuff you tried that didn't work)

## Development Process

1. Clone the repository:
```bash
git clone https://github.com/usexr/gather-ts.git
```

2. Install dependencies:
```bash
npm install
```

3. Run tests:
```bash
npm test
```

4. Make your changes and add/update tests as needed.

5. Run the linter:
```bash
npm run lint
```

6. Build the project:
```bash
npm run build
```

## Testing

We use Jest for testing. To run tests:

```bash
npm test
```

For test coverage:

```bash
npm run test:coverage
```

## Coding Style

- We use TypeScript
- We use ESLint for linting
- We follow the [Conventional Commits](https://www.conventionalcommits.org/) specification
- Write clear, readable code with meaningful variable names
- Comment complex logic, but prefer self-documenting code
- Keep functions small and focused

## Documentation

- Update the README.md if needed
- Add JSDoc comments for new functions and classes
- Update CHANGELOG.md with your changes
- Keep documentation up to date with code changes

## License
By contributing, you agree that your contributions will be licensed under its MIT License.

================
File: eslint.config.mjs
================
import globals from "globals";
import pluginJs from "@eslint/js";
import tseslint from "typescript-eslint";
import react from "eslint-plugin-react";

export default [
  {
    ignores: ['dist/**', 'node_modules/**'],
  },
  {
    files: ["**/*.{js,mjs,cjs,ts,tsx}"],
    languageOptions: { 
      globals: {
        ...globals.node,
        ...globals.browser
      }
    },
    plugins: {
      react: react
    }
  },
  pluginJs.configs.recommended,
  ...tseslint.configs.recommended,
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/no-require-imports': 'off',
      'no-case-declarations': 'off'
    }
  }
];

================
File: jest.config.ts
================
import type { Config } from '@jest/types';

const config: Config.InitialOptions = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  transform: {
    '^.+\\.ts$': 'ts-jest'
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1'
  },
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov'],
  verbose: true
};

export default config;

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Andrew Robb

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: madge.config.js
================
// madge.config.js
const path = require('path');

module.exports = {
  webpackConfig: {
    resolve: {
      extensions: ['.ts', '.tsx', '.js', '.jsx', '.json'],
      alias: {
        '@': path.resolve(__dirname, './src'),
      },
      modules: [
        path.resolve(__dirname, 'src'),
        path.resolve(__dirname, 'node_modules'),
      ],
    }
  }
};

================
File: package.json
================
{
  "name": "gather-ts",
  "version": "0.1.0",
  "description": "A powerful code analysis and packaging tool designed for creating AI-friendly code representations for javascript and typescript projects.",
  "main": "dist/src/index.js",
  "types": "dist/src/index.d.ts",
  "bin": {
    "gather-ts": "dist/src/cli.js"
  },
  "files": [
    "dist",
    "README.md",
    "LICENSE"
  ],
  "scripts": {
    "clean": "rimraf dist",
    "build": "npm run clean && tsc",
    "prepare": "npm run build",
    "prepublishOnly": "npm run test && npm run lint",
    "preversion": "npm run lint",
    "version": "npm run format && git add -A src",
    "postversion": "git push && git push --tags",
    "start": "node -r ./dist/src/register.js dist/src/cli.js",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "docs": "typedoc",
    "audit:fix": "npm audit fix",
    "build:docs": "typedoc"
  },
  "keywords": [
    "code-analysis",
    "dependency-analysis",
    "typescript",
    "ai",
    "code-review",
    "static-analysis",
    "dependency-graph",
    "code-visualization",
    "documentation",
    "development-tools"
  ],
  "author": {
    "name": "Andrew Robb",
    "url": "https://github.com/usexr"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/usexr/gather-ts.git"
  },
  "bugs": {
    "url": "https://github.com/usexr/gather-ts/issues"
  },
  "homepage": "https://github.com/usexr/gather-ts#readme",
  "engines": {
    "node": ">=14.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "@dqbd/tiktoken": "^1.0.7",
    "commander": "^11.0.0",
    "dotenv": "^16.3.1",
    "madge": "^6.1.0",
    "micromatch": "^4.0.5",
    "module-alias": "^2.2.3",
    "zod": "^3.22.2"
  },
  "devDependencies": {
    "@eslint/js": "9.19.0",
    "@types/jest": "^29.5.5",
    "@types/madge": "^5.0.0",
    "@types/micromatch": "^4.0.2",
    "@types/module-alias": "^2.0.4",
    "@types/node": "^20.6.2",
    "@typescript-eslint/eslint-plugin": "^6.7.0",
    "@typescript-eslint/parser": "^6.7.0",
    "eslint": "8.57.1",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "eslint-plugin-react": "7.37.4",
    "globals": "15.14.0",
    "husky": "^8.0.3",
    "jest": "^29.7.0",
    "lint-staged": "^14.0.1",
    "prettier": "^3.0.3",
    "rimraf": "^6.0.1",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.1",
    "ts-node-dev": "^2.0.0",
    "tsconfig-paths": "^4.2.0",
    "typedoc": "^0.27.1",
    "typedoc-plugin-markdown": "^4.4.1",
    "typescript": "^5.2.2",
    "typescript-eslint": "8.23.0"
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "*.ts": [
      "eslint --fix",
      "prettier --write"
    ]
  }
}

================
File: README.md
================
# gather-ts

A powerful code analysis and packaging tool designed for creating AI-friendly code representations. Gather-ts analyzes your codebase, resolves dependencies, and generates a comprehensive single-file representation optimized for AI analysis.

[![npm version](https://badge.fury.io/js/gather-ts.svg)](https://badge.fury.io/js/gather-ts)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

## Features

- üìä Comprehensive code analysis with dependency resolution
- üîç Intelligent file filtering and ignore patterns
- üìù Token-aware processing with multiple model support
- üöÄ High performance with batch processing and caching
- ‚ö°Ô∏è Support for TypeScript and JavaScript projects
- üõ†Ô∏è Configurable output formats
- üìà Detailed metrics and analytics

## Installation

Install globally:
```bash
npm install -g gather-ts
```

Or as a project dependency:
```bash
npm install --save-dev gather-ts
```

## Quick Start

1. Navigate to your project directory:
```bash
cd your-project
```

2. Generate a default configuration:
```bash
gather-ts --init
```

3. Run the analysis:
```bash
gather-ts src/index.ts --output analysis.txt
```

## Usage

### Basic Command Structure

```bash
gather-ts <files...> --output <output> [options]
```

### Arguments

- `files`: Entry files to analyze (comma or space separated)
- `--output, -o`: Output file path
- `--root, -r`: Project root directory (default: current directory)
- `--depth, -d`: Maximum depth for dependency analysis
- `--debug`: Enable debug logging
- `--batch-size`: Batch size for processing files
- `--metrics`: Include performance metrics in output
- `--config, -c`: Path to custom config file
- `--encoding`: File encoding (default: utf8)
- `--ignore`: Additional patterns to ignore
- `--require`: Required files to include
- `--init`: Initialize configuration in current directory

### Examples

Analyze a single file:
```bash
gather-ts src/app/page.tsx --output output.txt
```

Analyze multiple files with metrics:
```bash
gather-ts src/app/page.tsx,src/components/Button.tsx --output output.txt --metrics
```

Custom configuration and depth:
```bash
gather-ts src/index.ts --output analysis.txt --config custom-config.json --depth 3
```

## Configuration

Gather-ts can be configured using a `gather-ts.config.json` file in your project root. Generate a default configuration using:

```bash
gather-ts --init
```

### Configuration Options

```json
{
  "maxDepth": 5,
  "topFilesCount": 5,
  "showTokenCount": true,
  "tokenizer": {
    "model": "gpt-4",
    "showWarning": true
  },
  "outputFormat": {
    "includeSummaryInFile": true,
    "includeGenerationTime": true,
    "includeUsageGuidelines": true
  },
  "debug": false,
  "cacheTokenCounts": true
}
```

### Configuration Fields

| Field | Type | Description | Default |
|-------|------|-------------|---------|
| maxDepth | number | Maximum depth for dependency analysis | 5 |
| topFilesCount | number | Number of top files to show in summary | 5 |
| showTokenCount | boolean | Show token counts in output | true |
| tokenizer.model | string | Model to use for tokenization | "gpt-4" |
| tokenizer.showWarning | boolean | Show warnings for token limits | true |

## File Ignoring

Gather-ts uses both `.gitignore` and `.gather-ts-ignore` files for determining which files to process. Create a `.gather-ts-ignore` file in your project root to specify additional ignore patterns:

```
# Ignore test files
**/*.test.ts
**/*.spec.ts

# Ignore documentation
docs/
*.md

# Ignore specific directories
temp/
build/
```

## API Usage

You can also use gather-ts programmatically in your Node.js applications:

```typescript
import { configureContainer } from 'gather-ts';

async function analyzeCode() {
  const container = await configureContainer(process.cwd(), {
    debug: true,
    maxCacheAge: 7 * 24 * 60 * 60 * 1000, // 7 days
    fileExtensions: ['ts', 'tsx', 'js', 'jsx']
  });

  const compiler = container.resolve(ServiceTokens.COMPILER);
  
  const result = await compiler.compile({
    entryFiles: ['src/index.ts'],
    outputFile: 'analysis.txt',
    includeMetrics: true
  });

  console.log(`Analysis complete! Output: ${result.outputPath}`);
}
```

## Error Handling

Gather-ts provides detailed error messages and validation. Common error scenarios:

- Invalid configuration
- File access issues
- Dependency resolution failures
- Token counting errors

Errors include context and suggestions for resolution.

## Performance Tips

1. Use appropriate depth limits for large projects
2. Enable token count caching for faster processing
3. Use batch processing for large file sets
4. Ignore unnecessary files using `.gather-ts-ignore`

## Contributing

Contributions are welcome! Please read our [Contributing Guide](CONTRIBUTING.md) for details on our code of conduct and the process for submitting pull requests.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Support

- File a bug report: [GitHub Issues](https://github.com/usexr/gather-ts/issues)
- Feature requests: [GitHub Issues](https://github.com/usexr/gather-ts/issues)
- Questions: [GitHub Discussions](https://github.com/usexr/gather-ts/discussions)

## Changelog

See [CHANGELOG.md](CHANGELOG.md) for a list of changes and version history.

## Authors

- **Andrew Robb** - *Initial work*

## Acknowledgments

- Thanks to all contributors
- Built with TypeScript and Node.js
- Inspired by the need for better AI code analysis tools

================
File: src/__tests__/index.test.ts
================
import * as gatherTs from '../index';

describe('gather-ts', () => {
  it('module can be imported', () => {
    expect(gatherTs).toBeDefined();
  });
});

================
File: src/cli.ts
================
// src/cli.ts

import { ICompileContext } from "@/core/compiler";
import EventEmitter from "events";
import path from "path";
import { IConfigManager } from "./config";
import { ServiceTokens } from "./container/Container";
import { configureContainer } from "./container/ContainerConfig";
import { IArgumentParser } from "./core/compiler";
import { ValidationError } from "./errors";
import { ICLI, ICLIMetrics, ICLIOptions, ICLIResult } from "./interfaces/cli";
import "./register";
import { ILogger, IFileSystem } from "./utils";

export class CLI extends EventEmitter implements ICLI {
  private readonly debug: boolean;
  private readonly exitOnError: boolean;
  isInitialized: boolean = false;
  private metrics: ICLIMetrics = {
    executionTime: 0,
    memoryUsage: 0,
    filesProcessed: 0,
    errors: 0,
    warnings: 0,
  };
  private startTime: number = Date.now();

  constructor(
    private readonly deps: {
      logger: ILogger;
      configManager: IConfigManager;
      compiler: ICompileContext;
      argumentParser: IArgumentParser;
      fileSystem: IFileSystem;
    },
    options: ICLIOptions = {}
  ) {
    super();
    this.debug = options.debug || false;
    this.exitOnError = options.exitOnError ?? true;
  }

  private logDebug(message: string): void {
    if (this.debug) {
      this.deps.logger.debug(`[CLI] ${message}`);
    }
  }

  public async initialize(): Promise<void> {
    this.logDebug("Initializing CLI");

    try {
      if (this.isInitialized) {
        this.logDebug("CLI already initialized");
        return;
      }

      this.startTime = Date.now();
      this.initializeMetrics();
      this.setupEventListeners();

      this.isInitialized = true;
      this.logDebug("CLI initialization complete");
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      this.deps.logger.error(`Failed to initialize CLI: ${err.message}`);
      throw err;
    }
  }

  public cleanup(): void {
    this.logDebug("Cleaning up CLI");
    this.removeAllListeners();
    this.isInitialized = false;
  }

  private initializeMetrics(): void {
    this.metrics = {
      executionTime: 0,
      memoryUsage: 0,
      filesProcessed: 0,
      errors: 0,
      warnings: 0,
    };
  }

  private setupEventListeners(): void {
    this.logDebug("Setting up event listeners");

    this.on("command:start", ({ command, options }) => {
      if (this.debug) {
        this.deps.logger.debug(`Starting command: ${command}`);
        this.deps.logger.debug(`Options: ${JSON.stringify(options, null, 2)}`);
      }
    });

    this.on("command:complete", ({ result }) => {
      this.metrics.executionTime = Date.now() - this.startTime;
      this.metrics.memoryUsage = process.memoryUsage().heapUsed;

      if (result.metrics) {
        Object.assign(this.metrics, result.metrics);
      }
    });

    this.on("error", ({ error, command }) => {
      this.metrics.errors++;
      if (command) {
        this.deps.logger.error(`Error in command ${command}:`);
      }
      this.deps.logger.error(error.message);
      if (error.stack && this.debug) {
        this.deps.logger.debug(error.stack);
      }
    });

    this.on("warning", ({ message }) => {
      this.metrics.warnings++;
      this.deps.logger.warn(message);
    });

    this.on("progress", ({ phase, completed, total, message }) => {
      const percentage = Math.round((completed / total) * 100);
      this.deps.logger.info(
        `${phase}: ${percentage}% (${completed}/${total}) ${message || ""}`
      );
    });
  }

  private async generateDefaultConfig(): Promise<ICLIResult> {
    this.logDebug("Generating default configuration");

    try {
      this.deps.logger.info(
        "No gather-ts.config.json found. Creating one with default settings..."
      );

      await this.deps.configManager.initialize();

      this.deps.logger.success(
        "Created default configuration file: gather-ts.config.json"
      );

      return {
        success: true,
        exitCode: 0,
        output: "Configuration initialized successfully",
      };
    } catch (error) {
      this.deps.logger.warn(
        "Could not create default config file. Using default settings."
      );
      return {
        success: false,
        exitCode: 1,
        error: error instanceof Error ? error : new Error(String(error)),
      };
    }
  }

  private validateRoot(root: string): string {
    if (!this.isInitialized) {
      throw new ValidationError("CLI not initialized");
    }

    this.logDebug(`Validating root directory: ${root}`);

    const absolutePath = path.resolve(root);
    if (!this.deps.fileSystem.exists(absolutePath)) {
      throw new ValidationError("Invalid root directory", {
        root: absolutePath,
      });
    }
    return absolutePath;
  }

  public async run(): Promise<ICLIResult> {
    if (!this.isInitialized) {
      throw new ValidationError("CLI not initialized");
    }

    const configManager = this.deps.configManager as IConfigManager;
    const compiler = this.deps.compiler as ICompileContext;

    // Check if required services are initialized
    if (!configManager.isInitialized) {
      await configManager.initialize();
    }
    if (!compiler.isInitialized) {
      await compiler.initialize();
    }

    this.logDebug("Starting CLI execution");

    try {
      // Parse command line arguments
      const compileOptions = this.deps.argumentParser.parseArguments(
        process.argv.slice(2)
      );

      const projectRoot = this.validateRoot(
        compileOptions.rootDir || process.cwd()
      );

      this.emit("command:start", {
        command: "compile",
        options: compileOptions,
        timestamp: Date.now(),
      });

      // Handle --init flag
      if (compileOptions.init) {
        return await this.generateDefaultConfig();
      }

      // Initialize compiler before using it
      await this.deps.compiler.initialize();

      // Process required files if specified
      if (compileOptions.requiredFiles?.length) {
        this.deps.logger.info("Processing required files...");
        for (const file of compileOptions.requiredFiles) {
          const absolutePath = path.resolve(projectRoot, file);
          if (!this.deps.fileSystem.exists(absolutePath)) {
            this.emit("warning", {
              message: `Required file not found: ${file}`,
              command: "compile",
              timestamp: Date.now(),
            });
          }
        }
      }

      // Forward progress events from compiler
      this.deps.compiler.on("progress", (progress) => {
        this.emit("progress", progress);
      });

      // Run compilation
      const result = await this.deps.compiler.compile({
        ...compileOptions,
        rootDir: projectRoot,
      });

      // Log results
      this.deps.logger.success(`\nAnalysis complete!`);
      this.deps.logger.info(`Files processed: ${result.filesProcessed}`);
      this.deps.logger.info(
        `Tokens analyzed: ${result.totalTokens.toLocaleString()}`
      );
      this.deps.logger.info(
        `Output: ${path.relative(projectRoot, result.outputPath)}`
      );

      // Show metrics if enabled
      if (compileOptions.includeMetrics) {
        const metrics = this.deps.compiler.getMetrics();
        this.deps.logger.info("\nPerformance Metrics:");
        this.deps.logger.info("------------------");
        this.deps.logger.info(`Processing Time: ${metrics.processingTime}ms`);
        this.deps.logger.info(
          `Memory Usage: ${(metrics.memoryUsage / 1024 / 1024).toFixed(2)}MB`
        );
        this.deps.logger.info(`Files: ${metrics.filesProcessed}`);
        this.deps.logger.info(`Errors: ${metrics.errors}`);
        this.deps.logger.info(`Warnings: ${metrics.warnings}`);
      }

      // Check for warnings
      const warning = this.deps.configManager.getTokenWarning(
        result.totalTokens
      );
      if (warning) {
        this.emit("warning", {
          message: warning,
          command: "compile",
          timestamp: Date.now(),
        });
      }

      const cliResult: ICLIResult = {
        success: true,
        exitCode: 0,
        output: result.outputPath,
        metrics: this.metrics,
      };

      this.emit("command:complete", {
        command: "compile",
        result: cliResult,
        timestamp: Date.now(),
      });

      return cliResult;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));

      this.emit("error", {
        error: err,
        command: "compile",
        timestamp: Date.now(),
      });

      if (err instanceof ValidationError) {
        this.deps.argumentParser.printUsage();
      }

      if (this.exitOnError) {
        process.exit(1);
      }

      return {
        success: false,
        exitCode: 1,
        error: err,
        metrics: this.metrics,
      };
    }
  }
}

async function main() {
  let cli: CLI | undefined;
  let container;

  const debug = process.argv.includes("--debug");

  // Parse root directory from command line args first
  const rootIndex = process.argv.indexOf("--root");
  const projectRoot =
    rootIndex > -1 ? process.argv[rootIndex + 1] : process.cwd();

  try {
    container = await configureContainer(projectRoot, {
      debug,
      maxCacheAge: 7 * 24 * 60 * 60 * 1000, // 7 days
      fileExtensions: ["ts", "tsx", "js", "jsx"],
    });

    if (!container) {
      throw new Error("Failed to configure container");
    }

    // Initialize container first
    await container.initialize();

    // Resolve and type cast services properly
    const logger = container.resolve<ILogger>(ServiceTokens.LOGGER);
    const configManager = container.resolve<IConfigManager>(
      ServiceTokens.CONFIG_MANAGER
    );
    const compiler = container.resolve<ICompileContext>(ServiceTokens.COMPILER);
    const argumentParser = container.resolve<IArgumentParser>(
      ServiceTokens.ARGUMENT_PARSER
    );
    const fileSystem = container.resolve<IFileSystem>(
      ServiceTokens.FILE_SYSTEM
    );

    if (debug) {
      logger.enableDebug();
      logger.debug("Debug mode enabled");
      logger.debug(`Current working directory: ${process.cwd()}`);
      logger.debug(`Command line arguments: ${process.argv.join(" ")}`);
    }

    // Initialize services sequentially
    await configManager.initialize();
    await compiler.initialize();
    await argumentParser.initialize();
    await fileSystem.initialize();

    cli = new CLI(
      {
        logger,
        configManager,
        compiler,
        argumentParser,
        fileSystem,
      },
      {
        debug,
        exitOnError: true,
      }
    );

    await cli.initialize();

    if (debug) {
      logger.debug("CLI initialized");
    }

    const result = await cli.run();

    if (!result.success) {
      process.exit(result.exitCode);
    }
  } catch (error) {
    console.error("Fatal error:", error);
    process.exit(1);
  } finally {
    if (cli) {
      cli.cleanup();
    }
    if (container) {
      container.cleanup();
    }
  }
}

// Make sure main is called correctly
if (require.main === module) {
  main().catch((error) => {
    console.error("Fatal error:", error);
    process.exit(1);
  });
}

================
File: src/config/ConfigManager.ts
================
// src/config/ConfigManager.ts

import { EventEmitter } from "events";
import { ConfigurationError, ValidationError } from "@/errors";
import {
  IConfigManager,
  IConfigManagerDeps,
  IConfigManagerOptions,
  IConfigChangeEvent,
  IConfigLoadOptions,
  IConfigMetrics,
} from "./interfaces/IConfigManager";
import { IGatherTSConfig as IGatherTSConfig, IConfigValidationResult } from "@/types/config";
import { TiktokenModel } from "@/types/models/tokenizer";
import { BaseService } from "@/types/services";

// Create a class that extends EventEmitter and implements needed methods
class EventEmitterBase extends EventEmitter {
  on(event: string | symbol, listener: (...args: any[]) => void): this {
    return super.on(event, listener);
  }

  emit(event: string | symbol, ...args: any[]): boolean {
    return super.emit(event, ...args);
  }

  removeAllListeners(event?: string | symbol): this {
    return super.removeAllListeners(event);
  }
}

const defaultConfig: IGatherTSConfig = {
  maxDepth: 5,
  topFilesCount: 5,
  showTokenCount: true,
  tokenizer: {
    model: "gpt-4" as TiktokenModel,
    showWarning: true,
  },
  outputFormat: {
    includeSummaryInFile: true,
    includeGenerationTime: true,
    includeUsageGuidelines: true,
  },
  debug: false,
  cacheTokenCounts: true,
};

export class ConfigManager extends BaseService implements IConfigManager {
  private eventEmitter: EventEmitterBase;
  private config: IGatherTSConfig;
  private readonly configPath: string;
  private readonly projectRoot: string;
  private readonly debug: boolean;
  private readonly watch: boolean;
  private watchHandler?: NodeJS.Timeout;
  private metrics: IConfigMetrics = {
    loads: 0,
    updates: 0,
    validationErrors: 0,
    lastUpdate: undefined,
  };

  constructor(
    projectRoot: string,
    private readonly deps: IConfigManagerDeps,
    options: IConfigManagerOptions = {},
  ) {
    super();
    this.eventEmitter = new EventEmitterBase();

    if (!projectRoot || !this.deps.fileSystem.exists(projectRoot)) {
      throw new ConfigurationError(
        "Project root directory does not exist",
        projectRoot,
      );
    }

    this.projectRoot = projectRoot;
    this.debug = options.debug || false;
    this.watch = options.watch || false;
    this.configPath =
      options.configPath ||
      this.deps.fileSystem.joinPath(projectRoot, "gather-ts.config.json");

    this.config = { ...defaultConfig };
    this.initializeMetrics();

    this.logDebug(`ConfigManager created with root: ${projectRoot}`);
    this.logDebug(`Using config path: ${this.configPath}`);
  }

  // Delegate EventEmitter methods
  public on(event: string | symbol, listener: (...args: any[]) => void): this {
    this.eventEmitter.on(event, listener);
    return this;
  }

  public emit(event: string | symbol, ...args: any[]): boolean {
    return this.eventEmitter.emit(event, ...args);
  }

  public removeAllListeners(event?: string | symbol): this {
    this.eventEmitter.removeAllListeners(event);
    return this;
  }

  public override async initialize(): Promise<void> {
    this.logDebug("Initializing ConfigManager");

    try {
      await super.initialize();
      await this.loadConfig();

      if (this.watch) {
        this.startWatching();
      }

      this.logDebug("ConfigManager initialization complete");
    } catch (error) {
      throw new ConfigurationError(
        `Failed to initialize ConfigManager: ${
          error instanceof Error ? error.message : String(error)
        }`,
        this.configPath,
      );
    }
  }

  public override cleanup(): void {
    this.logDebug("Cleaning up ConfigManager");

    if (this.watchHandler) {
      clearInterval(this.watchHandler);
      this.watchHandler = undefined;
    }

    this.removeAllListeners();
    super.cleanup();
  }

  private initializeMetrics(): void {
    this.metrics = {
      loads: 0,
      updates: 0,
      validationErrors: 0,
      lastUpdate: undefined,
    };
  }

  private logDebug(message: string): void {
    if (this.debug) {
      this.deps.logger.debug(message);
    }
  }

  public getConfig(): IGatherTSConfig {
    this.checkInitialized();
    return { ...this.config };
  }

  private startWatching(): void {
    this.logDebug("Starting config file watch");

    if (this.watchHandler) {
      clearInterval(this.watchHandler);
    }

    this.watchHandler = setInterval(async () => {
      try {
        const stats = this.deps.fileSystem.statSync(this.configPath);
        if (stats.mtime.getTime() !== this.metrics.lastUpdate) {
          this.logDebug("Config file change detected");
          await this.loadConfig({ isWatch: true });
        }
      } catch (error) {
        this.deps.logger.warn(
          `Error watching config file: ${
            error instanceof Error ? error.message : String(error)
          }`,
        );
      }
    }, 1000) as unknown as NodeJS.Timeout;
  }

  private async loadConfig(options: IConfigLoadOptions = {}): Promise<void> {
    this.logDebug(`Loading configuration${options.isWatch ? " (watch)" : ""}`);

    let fileConfig: Partial<IGatherTSConfig> = {};

    try {
      if (this.deps.fileSystem.exists(this.configPath)) {
        const configContent = await this.deps.fileSystem.readFile(
          this.configPath,
        );
        fileConfig = JSON.parse(configContent);
        this.logDebug("Loaded configuration from file");
      } else {
        this.logDebug("No config file found, using defaults");
      }

      const newConfig = {
        ...defaultConfig,
        ...fileConfig,
      };

      const validation = this.validateConfig(newConfig);
      if (!validation.isValid) {
        throw new ConfigurationError(
          `Configuration validation failed: ${validation.errors.join(", ")}`,
          this.configPath,
        );
      }

      const oldConfig = this.config;
      this.config = newConfig;

      this.metrics.loads++;
      this.metrics.lastUpdate = Date.now();

      this.emit("configChange", {
        type: "update",
        oldConfig,
        newConfig,
        timestamp: Date.now(),
        isWatch: options.isWatch,
      } as IConfigChangeEvent);
    } catch (error) {
      this.metrics.validationErrors++;
      throw new ConfigurationError(
        `Failed to load configuration: ${
          error instanceof Error ? error.message : String(error)
        }`,
        this.configPath,
      );
    }
  }

  public async updateConfig(
    updates: Partial<IGatherTSConfig>,
  ): Promise<IGatherTSConfig> {
    this.logDebug("Updating configuration");

    try {
      const newConfig = {
        ...this.config,
        ...updates,
      };

      const validation = this.validateConfig(newConfig);
      if (!validation.isValid) {
        throw new ValidationError(
          `Invalid configuration updates: ${validation.errors.join(", ")}`,
        );
      }

      const oldConfig = this.config;
      this.config = newConfig;

      this.metrics.updates++;
      this.metrics.lastUpdate = Date.now();

      await this.saveConfig();

      this.emit("configChange", {
        type: "update",
        oldConfig,
        newConfig,
        timestamp: Date.now(),
      } as IConfigChangeEvent);

      return this.getConfig();
    } catch (error) {
      throw new ConfigurationError(
        `Failed to update configuration: ${
          error instanceof Error ? error.message : String(error)
        }`,
        this.configPath,
      );
    }
  }

  public async saveConfig(): Promise<void> {
    this.logDebug("Saving configuration");

    try {
      const configString = JSON.stringify(this.config, null, 2);
      await this.deps.fileSystem.writeFile(this.configPath, configString);
      this.logDebug("Configuration saved successfully");
    } catch (error) {
      throw new ConfigurationError(
        `Failed to save configuration: ${
          error instanceof Error ? error.message : String(error)
        }`,
        this.configPath,
      );
    }
  }

  public reset(): void {
    this.logDebug("Resetting configuration to defaults");

    const oldConfig = this.config;
    this.config = { ...defaultConfig };
    this.metrics.updates++;
    this.metrics.lastUpdate = Date.now();

    this.emit("configChange", {
      type: "reset",
      oldConfig,
      newConfig: this.config,
      timestamp: Date.now(),
    } as IConfigChangeEvent);
  }

  public getMetrics(): IConfigMetrics {
    return { ...this.metrics };
  }

  public onConfigChange(callback: (event: IConfigChangeEvent) => void): void {
    this.on("configChange", callback);
  }

  public getProjectRoot(): string {
    return this.projectRoot;
  }

  public getTokenizerModel(): string {
    return this.config.tokenizer.model;
  }

  public getMaxDepth(): number | undefined {
    return this.config.maxDepth;
  }

  public shouldShowTokenCount(): boolean {
    return this.config.showTokenCount;
  }

  public getTopFilesCount(): number {
    return this.config.topFilesCount;
  }

  public isDebugEnabled(): boolean {
    return this.debug;
  }

  public getModelTokenLimit(): number {
    const limits: Record<TiktokenModel, number> = {
      "gpt-3.5-turbo": 16384,
      "gpt-4": 8192,
      "gpt-4o": 128000,
      "gpt-4o-mini": 128000,
      o1: 128000,
      "o1-mini": 128000,
      "o3-mini": 200000,
    };

    const limit = limits[this.config.tokenizer.model];
    if (!limit) {
      throw new ConfigurationError(
        `Unsupported model: ${this.config.tokenizer.model}`,
        this.configPath,
      );
    }

    return limit;
  }

  public getTokenWarning(totalTokens: number): string | null {
    if (!this.config.tokenizer.showWarning) return null;

    const limit = this.getModelTokenLimit();
    if (totalTokens > limit) {
      return `Total tokens (${totalTokens.toLocaleString()}) exceed ${
        this.config.tokenizer.model
      }'s context limit of ${limit.toLocaleString()}`;
    }
    return null;
  }

  public validateConfig(
    config: Partial<IGatherTSConfig>,
  ): IConfigValidationResult {
    this.logDebug("Validating configuration");

    const result: IConfigValidationResult = {
      isValid: true,
      errors: [],
      warnings: [],
    };

    try {
      // Validate with deps.validator
      this.deps.validator.validate(config, "config", {
        requiredFields: ["tokenizer", "outputFormat"],
      });

      // Validate tokenizer configuration
      if (config.tokenizer) {
        this.validateTokenizerConfig(config, result);
      }

      // Validate output format
      if (config.outputFormat) {
        this.validateOutputFormat(config, result);
      }

      // Validate max depth
      if (config.maxDepth !== undefined) {
        if (typeof config.maxDepth !== "number" || config.maxDepth < 0) {
          result.errors.push("maxDepth must be a positive number or undefined");
          result.isValid = false;
        } else if (config.maxDepth > 10) {
          result.warnings.push("High maxDepth value may impact performance");
        }
      }

      // Validate top files count
      if (config.topFilesCount !== undefined) {
        if (
          typeof config.topFilesCount !== "number" ||
          config.topFilesCount < 1
        ) {
          result.errors.push("topFilesCount must be a positive number");
          result.isValid = false;
        } else if (config.topFilesCount > 20) {
          result.warnings.push(
            "Large topFilesCount value may impact readability",
          );
        }
      }
    } catch (error) {
      result.errors.push(
        error instanceof Error ? error.message : String(error),
      );
      result.isValid = false;
    }

    // Update metrics if validation failed
    if (!result.isValid) {
      this.metrics.validationErrors++;
    }

    return result;
  }

  private validateTokenizerConfig(
    config: Partial<IGatherTSConfig>,
    result: IConfigValidationResult,
  ): void {
    const validModels: TiktokenModel[] = [
      "gpt-3.5-turbo",
      "gpt-4",
      "gpt-4o",
      "gpt-4o-mini",
      "o1",
      "o1-mini",
      "o3-mini",
    ];

    if (!config.tokenizer) {
      result.errors.push("Missing tokenizer configuration");
      result.isValid = false;
      return;
    }

    if (!validModels.includes(config.tokenizer.model)) {
      result.errors.push(
        `Invalid tokenizer model. Valid models are: ${validModels.join(", ")}`,
      );
      result.isValid = false;
    }

    if (typeof config.tokenizer.showWarning !== "boolean") {
      result.errors.push("tokenizer.showWarning must be a boolean");
      result.isValid = false;
    }
  }

  private validateOutputFormat(
    config: Partial<IGatherTSConfig>,
    result: IConfigValidationResult,
  ): void {
    if (!config.outputFormat) {
      result.errors.push("Missing output format configuration");
      result.isValid = false;
      return;
    }

    const booleanFields = [
      "includeSummaryInFile",
      "includeGenerationTime",
      "includeUsageGuidelines",
    ] as const;

    booleanFields.forEach(field => {
      if (
        config.outputFormat![field] !== undefined &&
        typeof config.outputFormat![field] !== "boolean"
      ) {
        result.errors.push(`outputFormat.${field} must be a boolean`);
        result.isValid = false;
      }
    });

    if (
      config.outputFormat.format !== undefined &&
      !["json", "text", "markdown"].includes(config.outputFormat.format)
    ) {
      result.errors.push(
        "outputFormat.format must be one of: json, text, markdown",
      );
      result.isValid = false;
    }
  }
}

Object.assign(ConfigManager.prototype, EventEmitter.prototype);

================
File: src/config/index.ts
================
export * from "./ConfigManager";
export * from "./validators/ConfigValidator";
export * from "./interfaces/IConfigManager";

================
File: src/config/interfaces/IConfigManager.ts
================
// src/config/interfaces/IConfigManager.ts

import { IService } from "@/types/services";
import { IFileSystem } from "@/utils/filesystem/interfaces/IFileSystem";
import { ILogger } from "@/utils/logging/interfaces/ILogger";
import { IValidator } from "@/utils/validation/interfaces/IValidator";
import { IGatherTSConfig, IConfigValidationResult } from "@/types/config";

/**
 * Dependencies required by ConfigManager
 */
export interface IConfigManagerDeps {
  fileSystem: IFileSystem;
  logger: ILogger;
  validator: IValidator;
}

/**
 * Configuration options for ConfigManager
 */
export interface IConfigManagerOptions {
  /** Custom config file path */
  configPath?: string;
  /** Enable debug mode */
  debug?: boolean;
  /** Watch for config changes */
  watch?: boolean;
}

/**
 * Options for loading configuration
 */
export interface IConfigLoadOptions {
  /** Whether the load is triggered by watch */
  isWatch?: boolean;
  /** Skip validation */
  skipValidation?: boolean;
  /** Merge strategy for arrays */
  arrayMergeStrategy?: "replace" | "concat" | "unique";
}

/**
 * Configuration change event data
 */
export interface IConfigChangeEvent {
  /** Type of change */
  type: "update" | "reset";
  /** Previous configuration */
  oldConfig?: IGatherTSConfig;
  /** New configuration */
  newConfig: IGatherTSConfig;
  /** Timestamp of change */
  timestamp: number;
  /** Whether change was from watch */
  isWatch?: boolean;
}

export interface IConfigValidator {
  validateConfig(config: Partial<IGatherTSConfig>): void;
  validateTokenizerConfig(config: Partial<IGatherTSConfig>): void;
  validateOutputFormat(config: Partial<IGatherTSConfig>): void;
  validateCustomText(config: Partial<IGatherTSConfig>): void;
  validateAll(config: Partial<IGatherTSConfig>): IConfigValidationResult;
}

/**
 * Configuration validation event data
 */
export interface IConfigValidationEvent {
  /** Validation result */
  result: IConfigValidationResult;
  /** Configuration being validated */
  config: Partial<IGatherTSConfig>;
  /** Timestamp of validation */
  timestamp: number;
}

/**
 * Configuration metrics
 */
export interface IConfigMetrics {
  /** Number of configuration loads */
  loads: number;
  /** Number of configuration updates */
  updates: number;
  /** Number of validation errors */
  validationErrors: number;
  /** Last update timestamp */
  lastUpdate?: number;
}

/**
 * Core ConfigManager interface
 */
export interface IConfigManager extends IService {
  // EventEmitter methods we need
  on(event: string | symbol, listener: (...args: any[]) => void): this;
  emit(event: string | symbol, ...args: any[]): boolean;
  removeAllListeners(event?: string | symbol): this;

  // Config-specific methods
  getConfig(): IGatherTSConfig;
  updateConfig(updates: Partial<IGatherTSConfig>): Promise<IGatherTSConfig>;
  saveConfig(): Promise<void>;
  reset(): void;
  getMetrics(): IConfigMetrics;
  onConfigChange(callback: (event: IConfigChangeEvent) => void): void;
  getProjectRoot(): string;
  getTokenizerModel(): string;
  getMaxDepth(): number | undefined;
  shouldShowTokenCount(): boolean;
  getTopFilesCount(): number;
  isDebugEnabled(): boolean;
  getModelTokenLimit(): number;
  getTokenWarning(totalTokens: number): string | null;
  validateConfig(config: Partial<IGatherTSConfig>): IConfigValidationResult;
}

/**
 * Static methods for ConfigManager
 */
export interface IConfigManagerStatic {
  /** Generate default configuration file */
  generateDefaultConfig(outputPath: string, fileSystem: IFileSystem): void;
}

/**
 * ConfigManager events map
 */
export interface IConfigManagerEvents {
  configChange: IConfigChangeEvent;
  configValidation: IConfigValidationEvent;
  error: Error;
  warning: string;
}

================
File: src/config/validators/ConfigValidator.ts
================
import { ValidationError } from "@/errors";
import { IConfigValidator } from "../interfaces/IConfigManager";
import {
  IGatherTSConfig,
  IOutputConfig,
  ICustomText,
  IConfigValidationResult,
} from "@/types/config";
import { TiktokenModel } from "@/types/models/tokenizer";

export class ConfigValidator implements IConfigValidator {
  public validateConfig(config: Partial<IGatherTSConfig>): void {
    // Validate required fields
    const requiredFields = ["tokenizer", "outputFormat"] as const;
    const missingFields = requiredFields.filter(field => !(field in config));

    if (missingFields.length > 0) {
      throw new ValidationError("Missing required configuration fields", {
        missingFields,
      });
    }

    // Validate individual sections
    this.validateMaxDepth(config);
    this.validateTokenizerConfig(config);
    this.validateOutputFormat(config);
    this.validateCustomText(config);
  }

  private validateMaxDepth(config: Partial<IGatherTSConfig>): void {
    if (
      config.maxDepth !== undefined &&
      (typeof config.maxDepth !== "number" || config.maxDepth < 0)
    ) {
      throw new ValidationError("Invalid maxDepth value", {
        maxDepth: config.maxDepth,
        expectedType: "positive number or undefined",
      });
    }
  }

  public validateTokenizerConfig(config: Partial<IGatherTSConfig>): void {
    const validModels: TiktokenModel[] = [
      "gpt-3.5-turbo",
      "gpt-4",
      "gpt-4o",
      "gpt-4o-mini",
      "o1",
      "o1-mini",
      "o3-mini",
    ];

    if (!config.tokenizer) {
      throw new ValidationError("Missing tokenizer configuration");
    }

    if (!validModels.includes(config.tokenizer.model)) {
      throw new ValidationError("Invalid tokenizer model", {
        providedModel: config.tokenizer.model,
        validModels,
      });
    }

    if (
      config.tokenizer.showWarning !== undefined &&
      typeof config.tokenizer.showWarning !== "boolean"
    ) {
      throw new ValidationError(
        "Invalid showWarning value in tokenizer config",
        {
          providedValue: config.tokenizer.showWarning,
          expectedType: "boolean",
        },
      );
    }
  }

  public validateOutputFormat(config: Partial<IGatherTSConfig>): void {
    if (!config.outputFormat) {
      throw new ValidationError("Missing output format configuration");
    }

    const formatKeys: Array<keyof IOutputConfig> = [
      "includeSummaryInFile",
      "includeGenerationTime",
      "includeUsageGuidelines",
    ];

    formatKeys.forEach(key => {
      if (
        config.outputFormat?.[key] !== undefined &&
        typeof config.outputFormat[key] !== "boolean"
      ) {
        throw new ValidationError(`Invalid outputFormat.${key} value`, {
          value: config.outputFormat[key],
          expectedType: "boolean",
        });
      }
    });

    if (
      config.outputFormat.format !== undefined &&
      !["json", "text", "markdown"].includes(config.outputFormat.format)
    ) {
      throw new ValidationError("Invalid output format", {
        providedValue: config.outputFormat.format,
        allowedValues: ["json", "text", "markdown"],
      });
    }
  }

  public validateCustomText(config: Partial<IGatherTSConfig>): void {
    if (!config.customText) {
      return;
    }

    const textKeys: Array<keyof ICustomText> = [
      "header",
      "footer",
      "beforeSummary",
      "afterSummary",
      "beforeFiles",
    ];

    textKeys.forEach(key => {
      if (
        config.customText![key] !== undefined &&
        typeof config.customText![key] !== "string"
      ) {
        throw new ValidationError(`Invalid customText.${key} value`, {
          value: config.customText![key],
          expectedType: "string",
        });
      }
    });
  }

  private validateRequiredFiles(config: Partial<IGatherTSConfig>): void {
    if (!config.requiredFiles) {
      return;
    }

    if (!Array.isArray(config.requiredFiles)) {
      throw new ValidationError("requiredFiles must be an array", {
        providedValue: config.requiredFiles,
        expectedType: "array",
      });
    }

    config.requiredFiles.forEach((file, index) => {
      if (typeof file !== "string") {
        throw new ValidationError(`Invalid required file at index ${index}`, {
          providedValue: file,
          expectedType: "string",
        });
      }
    });
  }

  public validateAll(config: Partial<IGatherTSConfig>): IConfigValidationResult {
    const result: IConfigValidationResult = {
      isValid: true,
      errors: [],
      warnings: [],
    };

    try {
      this.validateConfig(config);
    } catch (error) {
      result.isValid = false;
      if (error instanceof ValidationError) {
        result.errors.push(error.message);
        if (error.details) {
          result.errors.push(JSON.stringify(error.details));
        }
      } else {
        result.errors.push(
          error instanceof Error ? error.message : String(error),
        );
      }
    }

    // Add warnings for potentially problematic configurations
    if (config.maxDepth !== undefined && config.maxDepth > 10) {
      result.warnings.push("High maxDepth value may impact performance");
    }

    if (config.topFilesCount && config.topFilesCount > 20) {
      result.warnings.push("Large topFilesCount value may impact readability");
    }

    return result;
  }
}

================
File: src/container/Container.ts
================
// src/container/Container.ts

import { EventEmitter } from "events";
import { ValidationError } from "@/errors";
import {
  IContainer,
  IServiceIdentifier,
  IServiceFactory,
  IServiceRegistration,
} from "./interfaces/IContainer";
import { IService } from "@/types/services";

export class Container extends EventEmitter implements IContainer {
  private static instance: Container;
  private services: Map<string, IServiceRegistration> = new Map();
  isInitialized: boolean = false;
  private readonly debug: boolean;

  private constructor(debug: boolean = false) {
    super();
    this.debug = debug;
  }

  public static getInstance(debug: boolean = false): Container {
    if (!Container.instance) {
      Container.instance = new Container(debug);
    }
    return Container.instance;
  }

  private logDebug(message: string): void {
    if (this.debug) {
      console.debug(`[Container] ${message}`);
    }
  }

  public async initialize(): Promise<void> {
    this.logDebug("Initializing Container");

    try {
      if (this.isInitialized) {
        this.logDebug("Container already initialized");
        return;
      }

      this.emit("initialization:start", { timestamp: Date.now() });

      for (const [token, registration] of this.services.entries()) {
        const instance = registration.instance;
        if (instance && "initialize" in instance) {
          try {
            await instance.initialize();
            this.logDebug(`Initialized service: ${token}`);
          } catch (error) {
            throw new Error(
              `Failed to initialize service ${token}: ${error instanceof Error ? error.message : String(error)}`,
            );
          }
        }
      }

      this.isInitialized = true;
      this.emit("initialization:complete", { timestamp: Date.now() });
      this.logDebug("Container initialization complete");
    } catch (error) {
      this.handleError("initialization", error);
    }
  }

  public cleanup(): void {
    this.logDebug("Cleaning up Container");

    try {
      this.emit("cleanup:start", { timestamp: Date.now() });

      for (const [token, registration] of this.services.entries()) {
        const instance = registration.instance;
        if (instance && "cleanup" in instance) {
          try {
            instance.cleanup();
            this.logDebug(`Cleaned up service: ${token}`);
          } catch (error) {
            this.logDebug(
              `Error cleaning up service ${token}: ${error instanceof Error ? error.message : String(error)}`,
            );
          }
        }
      }

      this.services.clear();
      this.isInitialized = false;

      this.emit("cleanup:complete", { timestamp: Date.now() });
      this.logDebug("Container cleanup complete");
    } catch (error) {
      this.handleError("cleanup", error);
    }
  }

  private handleError(operation: string, error: unknown): never {
    const message = error instanceof Error ? error.message : String(error);
    throw new ValidationError(`Container ${operation} failed: ${message}`);
  }

  public register<T extends IService>(
    token: IServiceIdentifier,
    instance: T,
  ): void {
    this.logDebug(`Registering service: ${token}`);

    if (!token) {
      throw new ValidationError("Service token cannot be empty");
    }

    const tokenStr = token.toString();
    if (this.services.has(tokenStr)) {
      throw new ValidationError(`Service already registered: ${tokenStr}`);
    }

    this.services.set(tokenStr, {
      token,
      factory: () => instance,
      instance,
    });

    this.emit("service:registered", {
      token: tokenStr,
      timestamp: Date.now(),
    });
  }

  public registerFactory<T extends IService>(
    token: IServiceIdentifier,
    factory: IServiceFactory<T>,
  ): void {
    this.logDebug(`Registering factory: ${token}`);

    if (!token) {
      throw new ValidationError("Service token cannot be empty");
    }

    if (!factory || typeof factory !== "function") {
      throw new ValidationError("Factory must be a function");
    }

    const tokenStr = token.toString();
    this.services.set(tokenStr, {
      token,
      factory,
    });

    this.emit("service:registered", {
      token: tokenStr,
      timestamp: Date.now(),
    });
  }

  public resolve<T extends IService>(token: IServiceIdentifier): T {
    if (!this.isInitialized && !this.services.has(token.toString())) {
      throw new ValidationError("Container not initialized");
    }

    this.logDebug(`Resolving service: ${token}`);

    const tokenStr = token.toString();
    const registration = this.services.get(tokenStr);

    if (!registration) {
      throw new ValidationError(`No service registered for token: ${tokenStr}`);
    }

    try {
      if (!registration.instance) {
        const instance = registration.factory();
        if (instance instanceof Promise) {
          throw new ValidationError(
            "Async service factories are not supported",
          );
        }
        registration.instance = instance;
      }

      this.emit("service:resolved", {
        token: tokenStr,
        timestamp: Date.now(),
      });

      return registration.instance as T;
    } catch (error) {
      this.emit("service:error", {
        token: tokenStr,
        error: error instanceof Error ? error : new Error(String(error)),
        timestamp: Date.now(),
      });

      throw new ValidationError(
        `Failed to resolve service ${tokenStr}: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  public hasService(token: IServiceIdentifier): boolean {
    return this.services.has(token.toString());
  }

  public clear(): void {
    this.logDebug("Clearing all services");
    this.cleanup();
  }
}

export const ServiceTokens = {
  CONFIG_MANAGER: "ConfigManager",
  IGNORE_HANDLER: "IgnoreHandler",
  TOKEN_COUNTER: "TokenCounter",
  ERROR_HANDLER: "ErrorHandler",
  ERROR_UTILS: "ErrorUtils",
  FILE_SYSTEM: "FileSystem",
  DEPENDENCY_ANALYZER: "DependencyAnalyzer",
  LOGGER: "Logger",
  TOKEN_CACHE: "TokenCache",
  COMPILER: "Compiler",
  VALIDATOR: "Validator",
  ARGUMENT_PARSER: "ArgumentParser",
  TEMPLATE_MANAGER: "TemplateManager",
} as const;

export type ServiceToken = (typeof ServiceTokens)[keyof typeof ServiceTokens];

================
File: src/container/ContainerConfig.ts
================
// src/container/ContainerConfig.ts

import { Container, ServiceTokens } from "./Container";
import { ConfigManager } from "../config/ConfigManager";
import { IgnoreHandler } from "../core/dependency/IgnoreHandler";
import { TokenCounter } from "../core/tokenization/TokenCounter";
import { TokenCache } from "../core/tokenization/TokenCache";
import { ErrorHandler } from "../errors/handlers/ErrorHandler";
import { ErrorUtils } from "../errors/utils/ErrorUtils";
import { FileSystem } from "../utils/filesystem/FileSystem";
import { DependencyAnalyzer } from "../core/dependency/DependencyAnalyzer";
import { Logger } from "../utils/logging/Logger";
import { Validator } from "../utils/validation/Validator";
import { ArgumentParser } from "../core/compiler/ArgumentParser";
import { IContainerOptions, IContainer } from "./interfaces/IContainer";
import { ILogger } from "@/utils/logging/interfaces/ILogger";
import { IFileSystem } from "@/utils/filesystem/interfaces/IFileSystem";
import { IErrorUtils } from "@/errors/interfaces/IErrorUtils";
import { IConfigManager } from "@/config/interfaces/IConfigManager";
import { ITokenCache } from "@/core/tokenization/interfaces/ITokenCache";
import { IIgnoreHandler } from "@/core/dependency/interfaces/IIgnoreHandler";
import { IValidator } from "@/utils/validation/interfaces/IValidator";
import { ITokenCounter } from "@/core/tokenization/interfaces/ITokenCounter";
import { IDependencyAnalyzer } from "@/core/dependency/interfaces/IDependencyAnalyzer";
import { IErrorHandler } from "@/errors/interfaces/IErrorHandler";
import { IArgumentParser } from "@/core/compiler/interfaces/IArgumentParser";
import { ICompileContext } from "@/core/compiler/interfaces/ICompileContext";
import { CompileContext } from "@/core/compiler";
import { TemplateManager } from "@/core/templating/TemplateManager";
import { ITemplateManager } from "@/core/templating/interfaces/ITemplateManager";
import { registerDefaultTemplates } from "@/core/templating/DefaultTemplates";

export async function configureContainer(
  projectRoot: string,
  options: IContainerOptions = {},
): Promise<IContainer> {
  const container = Container.getInstance(options.debug);

  try {
    // First, create and initialize the logger
    container.registerFactory(ServiceTokens.LOGGER, () => {
      return new Logger(
        {
          outputStream: process.stdout,
          errorStream: process.stderr,
        },
        {
          enableDebug: options.debug,
          timestamp: options.debug,
          logLevel: options.debug ? "debug" : "info",
        },
      );
    });

    const logger = container.resolve<ILogger>(ServiceTokens.LOGGER);
    await logger.initialize();
    logger.debug("Configuring container services...");

    // Register FileSystem
    container.registerFactory(ServiceTokens.FILE_SYSTEM, () => {
      return new FileSystem({ logger }, { debug: options.debug });
    });

    const fileSystem = container.resolve<IFileSystem>(
      ServiceTokens.FILE_SYSTEM,
    );
    await fileSystem.initialize();

    // Register Validator
    container.registerFactory(ServiceTokens.VALIDATOR, () => {
      return new Validator({ logger }, { debug: options.debug });
    });

    const validator = container.resolve<IValidator>(ServiceTokens.VALIDATOR);
    await validator.initialize();

    // Register ErrorUtils
    container.registerFactory(ServiceTokens.ERROR_UTILS, () => {
      return new ErrorUtils({ logger }, { debug: options.debug });
    });

    const errorUtils = container.resolve<IErrorUtils>(
      ServiceTokens.ERROR_UTILS,
    );
    await errorUtils.initialize();

    // Register ErrorHandler
    container.registerFactory(ServiceTokens.ERROR_HANDLER, () => {
      return new ErrorHandler(
        {
          fileSystem,
          logger,
          errorUtils,
        },
        {
          logToConsole: true,
          logToFile: options.debug,
          logFilePath: options.debug
            ? fileSystem.joinPath(projectRoot, ".gather-ts", "error.log")
            : undefined,
          debug: options.debug,
        },
      );
    });

    const errorHandler = container.resolve<IErrorHandler>(
      ServiceTokens.ERROR_HANDLER,
    );
    await errorHandler.initialize();

    // Register ConfigManager
    container.registerFactory(ServiceTokens.CONFIG_MANAGER, () => {
      return new ConfigManager(
        projectRoot,
        {
          fileSystem,
          logger,
          validator,
        },
        { debug: options.debug },
      );
    });

    const configManager = container.resolve<IConfigManager>(
      ServiceTokens.CONFIG_MANAGER,
    );
    await configManager.initialize();

    // Register TokenCache
    container.registerFactory(ServiceTokens.TOKEN_CACHE, () => {
      return new TokenCache(
        projectRoot,
        {
          fileSystem,
          logger,
        },
        {
          debug: options.debug,
          maxCacheAge: options.maxCacheAge,
        },
      );
    });

    const tokenCache = container.resolve<ITokenCache>(
      ServiceTokens.TOKEN_CACHE,
    );
    await tokenCache.initialize();

    // Register IgnoreHandler
    container.registerFactory(ServiceTokens.IGNORE_HANDLER, () => {
      return new IgnoreHandler(
        projectRoot,
        {
          fileSystem,
          logger,
        },
        { debug: options.debug },
      );
    });

    const ignoreHandler = container.resolve<IIgnoreHandler>(
      ServiceTokens.IGNORE_HANDLER,
    );
    await ignoreHandler.initialize();

    // Register TokenCounter
    container.registerFactory(ServiceTokens.TOKEN_COUNTER, () => {
      return new TokenCounter(
        {
          configManager,
          fileSystem,
          logger,
          cache: tokenCache,
        },
        {
          debug: options.debug,
          batchSize: options.batchSize,
        },
      );
    });

    const tokenCounter = container.resolve<ITokenCounter>(
      ServiceTokens.TOKEN_COUNTER,
    );
    await tokenCounter.initialize();

    // Register DependencyAnalyzer
    container.registerFactory(ServiceTokens.DEPENDENCY_ANALYZER, () => {
      return new DependencyAnalyzer(
        {
          fileSystem,
          logger,
          ignoreHandler,
        },
        {
          debug: options.debug,
          fileExtensions: options.fileExtensions,
          tsConfigPath: options.customTsConfigPath,
        },
      );
    });

    const dependencyAnalyzer = container.resolve<IDependencyAnalyzer>(
      ServiceTokens.DEPENDENCY_ANALYZER,
    );
    await dependencyAnalyzer.initialize();

    // Register ArgumentParser
    container.registerFactory(ServiceTokens.ARGUMENT_PARSER, () => {
      return new ArgumentParser(
        {
          logger,
          fileSystem,
          validator,
        },
        { debug: options.debug },
      );
    });

    const argumentParser = container.resolve<IArgumentParser>(
      ServiceTokens.ARGUMENT_PARSER,
    );
    await argumentParser.initialize();

    container.registerFactory(ServiceTokens.TEMPLATE_MANAGER, () => {
      return new TemplateManager({ logger }, { debug: options.debug });
    });

    const templateManager = container.resolve<ITemplateManager>(
      ServiceTokens.TEMPLATE_MANAGER,
    );
    await templateManager.initialize();

    // Register Compiler
    container.registerFactory(ServiceTokens.COMPILER, () => {
      return new CompileContext(
        {
          configManager,
          ignoreHandler,
          tokenCounter,
          errorHandler,
          dependencyAnalyzer,
          logger,
          fileSystem,
          templateManager,
        },
        {
          debug: options.debug,
          batchSize: options.batchSize,
        },
      );
    });

    const compiler = container.resolve<ICompileContext>(ServiceTokens.COMPILER);
    await compiler.initialize();

    // Register default templates
    registerDefaultTemplates(templateManager);

    logger.debug("Container configuration complete");
    return container;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to configure container: ${errorMessage}`);
  }
}

export async function initializeContainer(
  container: IContainer,
): Promise<void> {
  const logger = container.resolve<ILogger>(ServiceTokens.LOGGER);

  try {
    logger.debug("Starting container initialization");
    await container.initialize();
    logger.debug("Container initialization complete");
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error(`Failed to initialize container: ${errorMessage}`);
    throw error;
  }
}

export function cleanupContainer(container: IContainer): void {
  try {
    const logger = container.resolve<ILogger>(ServiceTokens.LOGGER);
    logger.debug("Starting container cleanup");
    container.cleanup();
    logger.debug("Container cleanup complete");
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(`Failed to cleanup container: ${errorMessage}`);
    throw error;
  }
}

================
File: src/container/interfaces/IContainer.ts
================
// src/container/interfaces/IContainer.ts

import { IService } from "@/types/services";

export interface IServiceIdentifier {
  toString(): string;
}

export interface IServiceFactory<T extends IService> {
  (): T | Promise<T>;
}

export interface IServiceRegistration<T extends IService = any> {
  token: IServiceIdentifier;
  factory: IServiceFactory<T>;
  instance?: T;
  dependencies?: IServiceIdentifier[];
}

export interface IContainerEvents {
  "service:registered": { token: string; timestamp: number };
  "service:resolved": { token: string; timestamp: number };
  "service:error": { token: string; error: Error; timestamp: number };
  "initialization:start": { timestamp: number };
  "initialization:complete": { timestamp: number };
  "cleanup:start": { timestamp: number };
  "cleanup:complete": { timestamp: number };
}

export interface IContainer extends IService {
  register<T extends IService>(token: IServiceIdentifier, instance: T): void;
  registerFactory<T extends IService>(
    token: IServiceIdentifier,
    factory: IServiceFactory<T>,
  ): void;
  resolve<T extends IService>(token: IServiceIdentifier): T;
  hasService(token: IServiceIdentifier): boolean;
  clear(): void;

  on<K extends keyof IContainerEvents>(
    event: K,
    listener: (data: IContainerEvents[K]) => void,
  ): this;

  off<K extends keyof IContainerEvents>(
    event: K,
    listener: (data: IContainerEvents[K]) => void,
  ): this;

  emit<K extends keyof IContainerEvents>(
    event: K,
    data: IContainerEvents[K],
  ): boolean;
}

export interface IContainerConfiguration {
  configureContainer(
    rootDir: string,
    options?: IContainerOptions,
  ): Promise<IContainer>;
}

export interface IContainerOptions {
  debug?: boolean;
  maxCacheAge?: number;
  fileExtensions?: string[];
  customTsConfigPath?: string;
  batchSize?: number;
}

================
File: src/core/compiler/ArgumentParser.ts
================
// src/core/compiler/ArgumentParser.ts

import path from "path";
import {
  IArgumentParser,
  IArgumentParserOptions,
  IParseOptions,
} from "./interfaces/IArgumentParser";
import { ICompileOptions } from "@/types/compiler";
import { ValidationError } from "@/errors";
import { IArgumentParserDeps } from "./interfaces/IArgumentParser";
import { BaseService } from "@/types/services";

export class ArgumentParser extends BaseService implements IArgumentParser {
  private readonly debug: boolean;
  private readonly maxDepth: number;
  private readonly defaultBatchSize: number;

  constructor(
    private readonly deps: IArgumentParserDeps,
    options: IArgumentParserOptions = {},
  ) {
    super();
    this.debug = options.debug || false;
    this.maxDepth = options.maxDepth || 10;
    this.defaultBatchSize = options.defaultBatchSize || 100;
  }

  public override async initialize(): Promise<void> {
    await super.initialize();
    this.logDebug("Initializing ArgumentParser");
  }

  public override cleanup(): void {
    this.logDebug("Cleaning up ArgumentParser");
    super.cleanup();
  }

  private logDebug(message: string): void {
    if (this.debug) {
      this.deps.logger.debug(message);
    }
  }

  public parseArguments(
    args: string[],
    options: IParseOptions = {},
  ): ICompileOptions {
    this.checkInitialized();
    this.logDebug(`Parsing arguments: ${args.join(" ")}`);

    try {
      if (!args.length && !options.allowEmpty) {
        throw new ValidationError("No arguments provided");
      }

      // First parse options to get root directory
      const restArgs = args.slice(1);
      let outputFile = "";
      const compileOptions: Partial<ICompileOptions> = {};

      // Process all args as options
      for (let i = 0; i < restArgs.length; i++) {
        const arg = restArgs[i];

        switch (arg) {
          case "--output":
          case "-o":
            i++;
            if (i >= restArgs.length) {
              throw new ValidationError("Output file path not provided");
            }
            outputFile = this.parseOutputFile(
              restArgs[i],
              options.requireOutput,
            );
            break;

          case "--root":
          case "-r":
            i++;
            if (i >= restArgs.length) {
              throw new ValidationError("Root directory not provided");
            }
            compileOptions.rootDir = this.parseRootDir(restArgs[i]);
            break;

          case "--depth":
          case "-d":
            i++;
            if (i >= restArgs.length) {
              throw new ValidationError("Depth value not provided");
            }
            compileOptions.maxDepth = this.parseDepth(restArgs[i]);
            break;

          case "--batch-size":
            i++;
            if (i >= restArgs.length) {
              throw new ValidationError("Batch size not provided");
            }
            const batchSize = this.deps.validator.validateNotEmpty(
              restArgs[i],
              "Batch size",
            );
            const parsedBatchSize = parseInt(batchSize);
            if (isNaN(parsedBatchSize) || parsedBatchSize <= 0) {
              throw new ValidationError("Batch size must be a positive number");
            }
            compileOptions.batchSize = parsedBatchSize;
            break;

          case "--config":
          case "-c":
            i++;
            if (i >= restArgs.length) {
              throw new ValidationError("Config path not provided");
            }
            const configPath = this.deps.validator.validateNotEmpty(
              restArgs[i],
              "Config path",
            );
            if (!this.deps.fileSystem.exists(configPath)) {
              throw new ValidationError(`Config file not found: ${configPath}`);
            }
            compileOptions.config = { path: configPath };
            break;

          case "--encoding":
            i++;
            if (i >= restArgs.length) {
              throw new ValidationError("Encoding not provided");
            }
            const encoding = this.deps.validator.validateNotEmpty(
              restArgs[i],
              "Encoding",
            );
            if (!this.isValidEncoding(encoding)) {
              throw new ValidationError(`Invalid encoding: ${encoding}`);
            }
            compileOptions.encoding = encoding as BufferEncoding;
            break;

          case "--ignore":
            i++;
            compileOptions.ignorePatterns = this.parseIgnorePatterns(
              restArgs.slice(i),
            );
            i += (compileOptions.ignorePatterns?.length || 0) - 1;
            break;

          case "--require":
            i++;
            compileOptions.requiredFiles = this.parseRequiredFiles(
              restArgs.slice(i),
            );
            i += (compileOptions.requiredFiles?.length || 0) - 1;
            break;

          case "--init":
            compileOptions.init = true;
            break;

          case "--metrics":
            compileOptions.includeMetrics = true;
            break;

          case "--debug":
            compileOptions.debug = true;
            break;

          default:
            if (arg.startsWith("-")) {
              throw new ValidationError(`Unknown option: ${arg}`);
            }
        }
      }

      // Extract entry files first (should be first argument)
      const entryFiles = args[0]
        ? this.parseEntryFiles(args[0], compileOptions.rootDir)
        : [];

      // Combine everything into final options
      const result = {
        entryFiles,
        outputFile,
        ...compileOptions,
      };

      this.logDebug(`Parsed options: ${JSON.stringify(result)}`);
      return result;
    } catch (error) {
      throw new ValidationError(
        `Failed to parse arguments: ${
          error instanceof Error ? error.message : String(error)
        }`,
      );
    }
  }

  private parseEntryFiles(filesArg: string, rootDir?: string): string[] {
    this.logDebug(
      `Parsing entry files: ${filesArg} with root: ${
        rootDir || "not specified"
      }`,
    );

    this.deps.validator.validateNotEmpty(filesArg, "Entry files argument");

    const files = filesArg
      .split(",")
      .map(f => f.trim())
      .filter(f => f.length > 0);

    if (files.length === 0) {
      throw new ValidationError("No valid entry files provided");
    }

    // Validate each file exists
    files.forEach(file => {
      this.deps.validator.validatePath(file, "Entry file");
      const absolutePath = rootDir
        ? this.deps.fileSystem.resolvePath(rootDir, file)
        : this.deps.fileSystem.resolvePath(file);

      if (!this.deps.fileSystem.exists(absolutePath)) {
        throw new ValidationError(`Entry file does not exist: ${file}`);
      }
    });

    return files;
  }

  private parseOutputFile(outputArg: string, required: boolean = true): string {
    this.logDebug(`Parsing output file: ${outputArg}`);

    if (required) {
      this.deps.validator.validateNotEmpty(outputArg, "Output file argument");
    }

    const outputFile = outputArg?.trim();
    if (!outputFile && required) {
      throw new ValidationError("Output file path cannot be empty");
    }

    // Ensure output directory exists or can be created
    if (outputFile) {
      const outputDir = this.deps.fileSystem.getDirName(outputFile);
      if (!this.deps.fileSystem.exists(outputDir)) {
        try {
          this.deps.fileSystem.createDirectory(outputDir, true);
          this.logDebug(`Created output directory: ${outputDir}`);
        } catch (error) {
          throw new ValidationError(
            `Cannot create output directory: ${
              error instanceof Error ? error.message : String(error)
            }`,
          );
        }
      }
    }

    return outputFile;
  }

  private parseOptions(args: string[]): Partial<ICompileOptions> {
    this.logDebug(`Parsing additional options: ${args.join(" ")}`);

    const options: Partial<ICompileOptions> = {};

    for (let i = 0; i < args.length; i++) {
      const arg = args[i];

      switch (arg) {
        case "--root":
        case "-r":
          i++;
          options.rootDir = this.parseRootDir(args[i]);
          break;

        case "--depth":
        case "-d":
          i++;
          options.maxDepth = this.parseDepth(args[i]);
          break;

        case "--batch-size":
          i++;
          const batchSize = this.deps.validator.validateNotEmpty(
            args[i],
            "Batch size",
          );
          const parsedBatchSize = parseInt(batchSize);
          if (isNaN(parsedBatchSize) || parsedBatchSize <= 0) {
            throw new ValidationError("Batch size must be a positive number");
          }
          options.batchSize = parsedBatchSize;
          break;

        case "--config":
        case "-c":
          i++;
          const configPath = this.deps.validator.validateNotEmpty(
            args[i],
            "Config path",
          );
          if (!this.deps.fileSystem.exists(configPath)) {
            throw new ValidationError(`Config file not found: ${configPath}`);
          }
          options.config = { path: configPath } as Record<string, unknown>;
          break;

        case "--encoding":
          i++;
          const encoding = this.deps.validator.validateNotEmpty(
            args[i],
            "Encoding",
          );
          if (!this.isValidEncoding(encoding)) {
            throw new ValidationError(`Invalid encoding: ${encoding}`);
          }
          options.encoding = encoding as BufferEncoding;
          break;

        case "--ignore":
          i++;
          options.ignorePatterns = this.parseIgnorePatterns(args.slice(i));
          i += (options.ignorePatterns?.length || 0) - 1;
          break;

        case "--require":
          i++;
          options.requiredFiles = this.parseRequiredFiles(args.slice(i));
          i += (options.requiredFiles?.length || 0) - 1;
          break;

        case "--init":
          options.init = true;
          break;

        case "--metrics":
          options.includeMetrics = true;
          break;

        case "--debug":
          options.debug = true;
          break;

        default:
          if (arg.startsWith("-")) {
            throw new ValidationError(`Unknown option: ${arg}`);
          }
      }
    }

    return options;
  }

  private parseRootDir(rootDir?: string): string {
    this.logDebug(`Parsing root directory: ${rootDir}`);

    this.deps.validator.validateNotEmpty(rootDir, "Root directory argument");

    const absolutePath = path.resolve(rootDir!);
    if (!this.deps.fileSystem.exists(absolutePath)) {
      throw new ValidationError("Root directory does not exist", {
        rootDir: absolutePath,
      });
    }

    return absolutePath;
  }

  private parseDepth(depthArg?: string): number {
    this.logDebug(`Parsing depth: ${depthArg}`);

    this.deps.validator.validateNotEmpty(depthArg, "Depth argument");

    const depth = parseInt(depthArg!);
    if (isNaN(depth)) {
      throw new ValidationError("Depth must be a number");
    }

    if (depth < 0) {
      throw new ValidationError("Depth cannot be negative");
    }

    if (depth > this.maxDepth) {
      throw new ValidationError(`Depth cannot exceed ${this.maxDepth}`);
    }

    return depth;
  }

  private isValidEncoding(encoding: string): encoding is BufferEncoding {
    const validEncodings: BufferEncoding[] = [
      "utf8",
      "utf-8",
      "utf16le",
      "latin1",
      "ascii",
      "base64",
      "hex",
      "binary",
      "ucs2",
    ];
    return validEncodings.includes(encoding as BufferEncoding);
  }

  private parseIgnorePatterns(args: string[]): string[] {
    this.logDebug(`Parsing ignore patterns: ${args.join(" ")}`);

    const patterns: string[] = [];
    for (const arg of args) {
      if (arg.startsWith("-")) break;
      patterns.push(arg);
    }
    return patterns;
  }

  private parseRequiredFiles(args: string[]): string[] {
    this.logDebug(`Parsing required files: ${args.join(" ")}`);

    const files: string[] = [];
    for (const arg of args) {
      if (arg.startsWith("-")) break;

      this.deps.validator.validatePath(arg, "Required file");
      if (!this.deps.fileSystem.exists(arg)) {
        this.deps.logger.warn(`Required file not found: ${arg}`);
        continue;
      }
      files.push(arg);
    }
    return files;
  }

  private validatePaths(entryFiles: string[], outputFile: string): void {
    entryFiles.forEach(file => {
      this.deps.validator.validatePath(file, "Entry file");
    });

    if (outputFile) {
      const outputDir = this.deps.fileSystem.getDirName(outputFile);
      this.deps.validator.validatePath(outputDir, "Output directory");
    }
  }

  public printUsage(): void {
    const usage = [
      "Usage: gather-ts <files...> --output <output> [options]",
      "",
      "Arguments:",
      "  files                Entry files to analyze (comma or space separated)",
      "",
      "Options:",
      "  -o, --output        Output file path",
      "  -r, --root          Project root directory (default: current directory)",
      "  -d, --depth         Maximum depth for dependency analysis",
      "  --debug             Enable debug logging",
      "  --batch-size        Batch size for processing files",
      "  --metrics           Include performance metrics in output",
      "  -c, --config        Path to custom config file",
      "  --encoding          File encoding (default: utf8)",
      "  --ignore            Additional patterns to ignore",
      "  --require           Required files to include",
      "  --init              Initialize configuration in current directory",
      "",
      "Examples:",
      "  # Single file with metrics",
      "  $ gather-ts src/app/page.tsx --output output.txt --metrics",
      "",
      "  # Multiple files with custom batch size",
      "  $ gather-ts src/app/page.tsx,src/components/Button.tsx --output output.txt --batch-size 50",
      "",
      "For more information, visit: https://github.com/usexr/gather-ts",
    ].join("\n");

    this.deps.logger.info(usage);
  }
}

================
File: src/core/compiler/CompileContext.ts
================
import path from "path";
import { EventEmitter } from "events";

import { ValidationError } from "@/errors";
import { IFileInfo, IFileWithContent } from "@/types/files";
import {
  ICompileMetrics,
  ICompileOptions,
  ICompileResult,
} from "@/types/compiler";
import {
  CompilePhase,
  ICompileContext,
  ICompileContextDeps,
  ICompileContextOptions,
  ICompileFileOptions,
  ICompilePhaseResult,
} from "./interfaces/ICompileContext";
import { IConfigManager } from "@/config";
import { IDependencyMap } from "dependency";

export class CompileContext extends EventEmitter implements ICompileContext {
  public isInitialized: boolean = false;
  private readonly debug: boolean;
  private readonly batchSize: number;
  private readonly includeMetrics: boolean;
  private startTime: number;
  private currentPhase?: CompilePhase;

  public readonly options: ICompileOptions;
  public readonly stats: {
    startTime: string;
    endTime: string;
    duration: number;
    totalFiles: number;
    processedFiles: number;
    skippedFiles: number;
    totalTokens: number;
  };
  public readonly dependencies: IDependencyMap;

  private metrics: ICompileMetrics = {
    filesProcessed: 0,
    totalTokens: 0,
    processingTime: 0,
    memoryUsage: 0,
    dependencyAnalysisTime: 0,
    tokenizationTime: 0,
    outputGenerationTime: 0,
    errors: 0,
    warnings: 0,
  };

  constructor(
    private readonly deps: ICompileContextDeps,
    options: ICompileContextOptions = {},
  ) {
    super();
    this.debug = options.debug || false;
    this.batchSize = options.batchSize || 100;
    this.includeMetrics = options.includeMetrics || false;
    this.startTime = Date.now();

    this.options = {
      entryFiles: [],
      outputFile: "",
      rootDir: "",
    };

    this.stats = {
      startTime: new Date().toISOString(),
      endTime: new Date().toISOString(),
      duration: 0,
      totalFiles: 0,
      processedFiles: 0,
      skippedFiles: 0,
      totalTokens: 0,
    };

    this.dependencies = {};
  }

  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      this.logDebug("CompileContext already initialized");
      return;
    }

    this.logDebug("Initializing CompileContext");

    try {
      // Initialize all required services
      await Promise.all([
        this.deps.ignoreHandler.initialize?.(),
        this.deps.tokenCounter.initialize?.(),
        this.deps.dependencyAnalyzer.initialize?.(),
      ]);

      this.startTime = Date.now();
      this.isInitialized = true;
      this.logDebug("CompileContext initialization complete");
    } catch (error) {
      this.handleError("initialization", error);
    }
  }

  public cleanup(): void {
    this.logDebug("Cleaning up CompileContext");

    // Cleanup all services
    this.deps.ignoreHandler.cleanup?.();
    this.deps.tokenCounter.cleanup?.();
    this.deps.dependencyAnalyzer.cleanup?.();

    this.removeAllListeners();
    this.isInitialized = false;
  }

  private logDebug(message: string): void {
    if (this.debug) {
      this.deps.logger.debug(`[CompileContext] ${message}`);
    }
  }

  private handleError(phase: string, error: unknown): never {
    const errorMessage = error instanceof Error ? error.message : String(error);
    this.metrics.errors++;
    this.emit("error", { error: error as Error, phase });
    throw new ValidationError(`Error in ${phase} phase: ${errorMessage}`);
  }

  private updateMetrics(update: Partial<ICompileMetrics>): void {
    Object.assign(this.metrics, update);
    this.metrics.processingTime = Date.now() - this.startTime;
    this.metrics.memoryUsage = process.memoryUsage().heapUsed;
  }

  private resetMetrics(): void {
    this.metrics = {
      filesProcessed: 0,
      totalTokens: 0,
      processingTime: 0,
      memoryUsage: 0,
      dependencyAnalysisTime: 0,
      tokenizationTime: 0,
      outputGenerationTime: 0,
      errors: 0,
      warnings: 0,
    };
    this.startTime = Date.now();
  }

  private emitProgress(
    completed: number,
    total: number,
    message?: string,
  ): void {
    if (!this.currentPhase) return;

    this.emit("progress", {
      phase: this.currentPhase,
      completed,
      total,
      message,
    });
  }

  private async executePhase<T>(
    phase: CompilePhase,
    executor: () => Promise<T>,
  ): Promise<T> {
    const startTime = Date.now();
    this.currentPhase = phase;

    try {
      this.emit("phase:start", { phase, timestamp: startTime });
      const result = await executor();

      const endTime = Date.now();
      const phaseResult: ICompilePhaseResult = {
        phase,
        success: true,
        data: result,
        metrics: {
          startTime,
          endTime,
          duration: endTime - startTime,
          memoryUsage: process.memoryUsage().heapUsed,
        },
      };

      this.emit("phase:end", {
        phase,
        timestamp: endTime,
        result: phaseResult,
      });
      return result;
    } catch (error) {
      this.handleError(phase, error);
    } finally {
      this.currentPhase = undefined;
    }
  }

  public async compile(options: ICompileOptions): Promise<ICompileResult> {
    if (!this.isInitialized) {
      throw new ValidationError("CompileContext not initialized");
    }

    // Update the options property with the provided options
    Object.assign(this.options, options);

    this.resetMetrics();
    this.logDebug("Starting compilation");

    try {
      const rootDir =
        options.rootDir || this.deps.configManager.getProjectRoot();

      // Validate entry files
      const entryFiles = await this.executePhase("initialization", async () => {
        return await this.deps.dependencyAnalyzer.validateEntryFiles(
          options.entryFiles,
          rootDir,
        );
      });

      // Analyze dependencies
      const dependencyAnalysis = await this.executePhase(
        "dependency-analysis",
        async () => {
          const startTime = Date.now();
          const result = await this.deps.dependencyAnalyzer.analyzeDependencies(
            entryFiles,
            rootDir,
          );

          this.updateMetrics({
            dependencyAnalysisTime: Date.now() - startTime,
          });

          return result;
        },
      );

      // Gather relevant files
      const relevantFiles = await this.executePhase(
        "file-processing",
        async () => {
          const files = await this.deps.dependencyAnalyzer.gatherDependencies(
            dependencyAnalysis.dependencies,
            entryFiles,
            options.maxDepth,
          );

          return files.map(file => ({
            absolute: file,
            relative: this.deps.fileSystem.getRelativePath(rootDir, file),
            path: this.deps.fileSystem.getRelativePath(rootDir, file),
          }));
        },
      );

      // Process required files
      const processedFiles = await this.processRequiredFiles(
        relevantFiles,
        rootDir,
      );

      // Read file contents
      const filesWithContent = await this.loadFileContents(processedFiles);

      // Generate token summary
      const stats = await this.executePhase("tokenization", async () => {
        const startTime = Date.now();
        const result =
          await this.deps.tokenCounter.generateSummary(filesWithContent);

        this.updateMetrics({
          tokenizationTime: Date.now() - startTime,
          totalTokens: result.totalTokens,
          filesProcessed: filesWithContent.length,
        });

        return result;
      });

      // Generate output
      const output = await this.executePhase("output-generation", async () => {
        const startTime = Date.now();
        const result = await this.generateOutput(
          filesWithContent,
          this.deps.configManager,
        );

        this.updateMetrics({
          outputGenerationTime: Date.now() - startTime,
        });

        return result;
      });

      // Ensure output directory exists
      await this.deps.fileSystem.createDirectory(
        path.dirname(options.outputFile),
        true,
      );

      // Write output file
      await this.deps.fileSystem.writeFile(options.outputFile, output);

      // Make sure to update stats and dependencies during compilation
      this.stats.startTime = new Date().toISOString();
      // ... update other stats as compilation progresses ...
      this.stats.endTime = new Date().toISOString();
      this.stats.duration = Date.now() - this.startTime;

      const result: ICompileResult = {
        filesProcessed: this.stats.processedFiles,
        outputPath: options.outputFile,
        totalTokens: this.stats.totalTokens,
        generationTime: this.stats.endTime,
        metadata: {
          createdAt: this.stats.startTime,
          updatedAt: this.stats.endTime,
          version: "1.0.0",
        },
      };

      this.logDebug("Compilation completed successfully");
      if (this.debug) {
        this.logDebug(`Metrics: ${JSON.stringify(this.getMetrics(), null, 2)}`);
      }

      return result;
    } catch (error) {
      this.handleError("compile", error);
    }
  }

  private async processRequiredFiles(
    relativeFiles: IFileInfo[],
    rootDir: string,
  ): Promise<IFileInfo[]> {
    this.logDebug("Processing required files");

    const config = this.deps.configManager.getConfig();
    const processedFiles = [...relativeFiles];

    if (config.requiredFiles?.length) {
      this.logDebug(
        `Found ${config.requiredFiles.length} required files in config`,
      );

      for (const requiredFile of config.requiredFiles) {
        const absolutePath = this.deps.fileSystem.resolvePath(
          rootDir,
          requiredFile,
        );

        if (!processedFiles.some(f => f.absolute === absolutePath)) {
          if (this.deps.fileSystem.exists(absolutePath)) {
            processedFiles.push({
              absolute: absolutePath,
              relative: this.deps.fileSystem.getRelativePath(
                rootDir,
                absolutePath,
              ),
              path: this.deps.fileSystem.getRelativePath(rootDir, absolutePath),
            });

            this.logDebug(`Added required file: ${requiredFile}`);
          } else {
            this.metrics.warnings++;
            this.deps.logger.warn(`Required file not found: ${requiredFile}`);
          }
        }
      }
    }

    return processedFiles;
  }

  private async loadFileContents(
    files: IFileInfo[],
    options: ICompileFileOptions = {}
  ): Promise<IFileWithContent[]> {
    this.logDebug(`Loading contents for ${files.length} files`);
  
    const result = await Promise.all(
      files.map(async file => {
        try {
          const content = await this.deps.fileSystem.readFile(file.absolute, {
            encoding: options.encoding || 'utf8' // Use encoding option
          });
  
          // Validate content if requested
          if (options.validateContent && (!content || content.trim() === "")) {
            this.deps.logger.warn(`Empty file content for: ${file.path}`);
            return {
              ...file,
              content: " ",
            };
          }
  
          // Check file size limit
          if (options.maxSize && Buffer.byteLength(content) > options.maxSize) {
            throw new ValidationError(`File exceeds size limit: ${file.path}`);
          }
  
          return {
            ...file,
            content,
          };
        } catch (error) {
          this.metrics.errors++;
          throw new ValidationError(
            `Failed to read file: ${error instanceof Error ? error.message : String(error)}`,
            { filePath: file.absolute },
          );
        }
      }),
    );
  
    // Use stats for caching and metrics
    this.stats.processedFiles += result.length;
    
    this.logDebug(`Loaded contents for ${result.length} files`);
    return result;
  }

  public getMetrics(): ICompileMetrics {
    return {
      ...this.metrics,
      processingTime: Date.now() - this.startTime,
      memoryUsage: process.memoryUsage().heapUsed,
    };
  }

  private async generateOutput(
    filesWithContent: IFileWithContent[],
    configManager: IConfigManager,
  ): Promise<string> {
    const generationTime = new Date().toISOString();
    const config = configManager.getConfig();
    const output: string[] = [];

    try {
      // Add main header
      output.push(
        this.deps.templateManager.render("mainHeader", {
          tool: "gather-ts",
          date: generationTime,
        }),
      );

      // Add file summary
      let customNotes = "";
      if (config.customText?.beforeSummary) {
        customNotes =
          "\n## Important Notes\n" + config.customText.beforeSummary;
      }

      output.push(
        this.deps.templateManager.render("fileSummary", {
          tool: "gather-ts",
          customNotes,
        }),
      );

      // Add repository structure
      const fileList = filesWithContent.map(file => file.path).join("\n");

      output.push(
        this.deps.templateManager.render("repositoryStructure", {
          fileList,
        }),
      );

      // Add repository files header
      output.push(this.deps.templateManager.render("repositoryFiles", {}));

      // Add each file
      let processed = 0;
      const total = filesWithContent.length;

      for (const file of filesWithContent) {
        output.push(
          this.deps.templateManager.render("fileEntry", {
            filePath: file.path,
            fileContent: file.content,
          }),
        );

        processed++;
        this.emit("progress", {
          phase: "output-generation",
          completed: processed,
          total,
          message: `Processing ${file.path}`,
        });
      }

      // Add footer if configured
      if (config.customText?.footer) {
        output.push("\n" + config.customText.footer);
      }

      const result = output.join("\n");

      // Validate output contains all expected sections
      this.validateOutput(result);

      return result;
    } catch (error) {
      this.deps.logger.error(
        `Failed to generate output: ${error instanceof Error ? error.message : String(error)}`,
      );
      throw new Error(
        `Output generation failed: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  private validateOutput(output: string): void {
    const requiredSections = [
      "File Summary",
      "Repository Structure",
      "Repository Files",
    ];

    for (const section of requiredSections) {
      if (!output.includes(section)) {
        throw new Error(
          `Generated output missing required section: ${section}`,
        );
      }
    }

    // Validate basic structure
    if (!output.includes("================")) {
      throw new Error("Generated output missing file separators");
    }

    this.logDebug("Output validation complete");
  }

  private generateMetricsReport(): string {
    const metrics = this.getMetrics();
    return [
      "================================================================",
      "Performance Metrics",
      "================================================================",
      "",
      `Processing Time: ${metrics.processingTime}ms`,
      `Dependency Analysis: ${metrics.dependencyAnalysisTime}ms`,
      `Tokenization: ${metrics.tokenizationTime}ms`,
      `Output Generation: ${metrics.outputGenerationTime}ms`,
      `Memory Usage: ${(metrics.memoryUsage / 1024 / 1024).toFixed(2)}MB`,
      `Files Processed: ${metrics.filesProcessed}`,
      `Total Tokens: ${metrics.totalTokens}`,
      `Errors: ${metrics.errors}`,
      `Warnings: ${metrics.warnings}`,
      "",
    ].join("\n");
  }
}

================
File: src/core/compiler/index.ts
================
export * from "./ArgumentParser";
export * from "./CompileContext";
export * from "./interfaces/IArgumentParser";
export * from "./interfaces/ICompileContext";

================
File: src/core/compiler/interfaces/IArgumentParser.ts
================
import { ICompileOptions } from "@/types/compiler";
import { ILogger, IValidator } from "@/utils";
import { IFileSystem } from "@/utils/filesystem/interfaces/IFileSystem";
import { IService } from "@/types/services";

export interface IArgumentParserDeps {
  logger: ILogger;
  fileSystem: IFileSystem;
  validator: IValidator;
}

export interface IArgumentParserOptions {
  debug?: boolean;
  maxDepth?: number;
  defaultBatchSize?: number;
}

export interface IArgumentParser extends IService {
  parseArguments(args: string[], options?: IParseOptions): ICompileOptions;
  printUsage(): void;
}

export interface IParseOptions {
  allowEmpty?: boolean;
  requireOutput?: boolean;
  validatePaths?: boolean;
}

================
File: src/core/compiler/interfaces/ICompileContext.ts
================
// src/core/compiler/interfaces/ICompileContext.ts

import { IService } from "@/types/services";
import {
  ICompileMetrics,
  ICompileOptions,
  ICompileResult,
} from "@/types/compiler";
import { IConfigManager } from "@/config";
import { IIgnoreHandler, IDependencyAnalyzer } from "@/core/dependency";
import { ITokenCounter } from "@/core/tokenization";
import { IErrorHandler } from "@/errors/interfaces/IErrorHandler";
import { ILogger, IFileSystem } from "@/utils";
import { ITemplateManager } from "@/core/templating/interfaces/ITemplateManager";

export type CompilePhase =
  | "initialization"
  | "dependency-analysis"
  | "file-processing"
  | "tokenization"
  | "output-generation"
  | "completion";

export interface ICompileContextDeps {
  configManager: IConfigManager;
  ignoreHandler: IIgnoreHandler;
  tokenCounter: ITokenCounter;
  errorHandler: IErrorHandler;
  dependencyAnalyzer: IDependencyAnalyzer;
  logger: ILogger;
  fileSystem: IFileSystem;
  templateManager: ITemplateManager;
}

export interface ICompilePhaseResult {
  phase: string;
  success: boolean;
  error?: Error;
  data?: unknown;
  metrics?: {
    startTime: number;
    endTime: number;
    duration: number;
    memoryUsage: number;
  };
}

export interface ICompileFileOptions {
  encoding?: BufferEncoding;
  validateContent?: boolean;
  maxSize?: number;
}

export interface ICompileProgress {
  phase: CompilePhase;
  completed: number;
  total: number;
  message?: string;
}

export interface ICompileContextEvents {
  "phase:start": { phase: string; timestamp: number };
  "phase:end": {
    phase: string;
    timestamp: number;
    result: ICompilePhaseResult;
  };
  error: { error: Error; phase?: string };
  warning: { message: string; phase?: string };
  progress: ICompileProgress;
}

export interface ICompileContextOptions {
  debug?: boolean;
  batchSize?: number;
  includeMetrics?: boolean;
  maxConcurrency?: number;
  hooks?: ICompileContextHooks;
}

export interface ICompileContextHooks {
  beforeCompile?: (options: ICompileOptions) => Promise<void>;
  afterCompile?: (result: ICompileResult) => Promise<void>;
  onError?: (error: Error) => Promise<void>;
  beforePhase?: (phase: string) => Promise<void>;
  afterPhase?: (phase: string, result: ICompilePhaseResult) => Promise<void>;
}

export interface ICompileContext extends IService {
  // Add Service interface methods
  isInitialized: boolean;
  initialize(): Promise<void>;
  cleanup(): void;

  // Add existing compile methods
  compile(options: ICompileOptions): Promise<ICompileResult>;
  getMetrics(): ICompileMetrics;

  // Add event emitter methods
  on(event: "progress", listener: (progress: ICompileProgress) => void): this;
  off(event: "progress", listener: (progress: ICompileProgress) => void): this;
  emit(event: "progress", progress: ICompileProgress): boolean;
}

================
File: src/core/dependency/DependencyAnalyzer.ts
================
// src/core/dependency/DependencyAnalyzer.ts

import madge from "madge";
import { EventEmitter } from "events";
import { DependencyAnalysisError, ValidationError } from "@/errors";
import {
  IDependencyAnalyzer,
  IDependencyAnalyzerDeps,
  IDependencyAnalyzerOptions,
  IAnalyzeOptions,
  IDependencyAnalysisResult,
  IDependencyValidationResult,
  IDependencyProgress,
} from "./interfaces/IDependencyAnalyzer";
import { IDependencyMap } from "dependency";

export class DependencyAnalyzer
  extends EventEmitter
  implements IDependencyAnalyzer
{
  isInitialized: boolean = false;
  private readonly debug: boolean;
  private readonly webpackConfigPath?: string;
  private readonly tsConfigPath: string;
  private readonly fileExtensions: string[];
  private readonly maxConcurrency: number;
  private originalCwd: string;

  constructor(
    private readonly deps: IDependencyAnalyzerDeps,
    options: IDependencyAnalyzerOptions = {},
  ) {
    super();
    this.debug = options.debug || false;
    this.webpackConfigPath = options.webpackConfigPath;
    this.tsConfigPath = options.tsConfigPath || "tsconfig.json";
    this.fileExtensions = options.fileExtensions || ["ts", "tsx"];
    this.maxConcurrency = options.maxConcurrency || 4;
    this.originalCwd = process.cwd();
  }

  private logDebug(message: string): void {
    if (this.debug) {
      this.deps.logger.debug(`[DependencyAnalyzer] ${message}`);
    }
  }

  private checkInitialized(): void {
    if (!this.isInitialized) {
      throw new Error("DependencyAnalyzer not initialized");
    }
  }

  public async initialize(): Promise<void> {
    this.logDebug("Initializing DependencyAnalyzer");

    try {
      if (this.isInitialized) {
        this.logDebug("DependencyAnalyzer already initialized");
        return;
      }

      // Verify configuration files exist
      if (
        this.webpackConfigPath &&
        !this.deps.fileSystem.exists(this.webpackConfigPath)
      ) {
        this.deps.logger.warn(
          `Webpack config not found at: ${this.webpackConfigPath}`,
        );
      }

      if (!this.deps.fileSystem.exists(this.tsConfigPath)) {
        this.deps.logger.warn(
          `TypeScript config not found at: ${this.tsConfigPath}`,
        );
      }

      // Store original working directory
      this.originalCwd = process.cwd();

      this.isInitialized = true;
      this.logDebug("DependencyAnalyzer initialization complete");
    } catch (error) {
      this.handleError("initialize", error);
    }
  }

  public cleanup(): void {
    this.logDebug("Cleaning up DependencyAnalyzer");
    this.restoreWorkingDirectory();
    this.removeAllListeners();
    this.isInitialized = false;
  }

  private handleError(
    operation: string,
    error: unknown,
    context?: Record<string, unknown>,
  ): never {
    const message = error instanceof Error ? error.message : String(error);
    const analysisError = new DependencyAnalysisError(
      `Dependency analysis ${operation} failed: ${message}`,
      context?.entryPoint as string,
      context?.dependencies as string[],
    );
    this.deps.logger.error(analysisError.message);
    this.emit("analysis:error", {
      error: analysisError,
      phase: operation,
      timestamp: Date.now(),
    });
    throw analysisError;
  }

  private changeWorkingDirectory(dir: string): void {
    this.originalCwd = process.cwd();
    process.chdir(dir);
    this.logDebug(`Changed working directory to: ${dir}`);
  }

  private restoreWorkingDirectory(): void {
    if (process.cwd() !== this.originalCwd) {
      process.chdir(this.originalCwd);
      this.logDebug(`Restored working directory to: ${this.originalCwd}`);
    }
  }

  private emitProgress(
    phase: IDependencyProgress["phase"],
    completed: number,
    total: number,
    currentFile?: string,
  ): void {
    this.emit("progress", {
      phase,
      completed,
      total,
      currentFile,
    });
  }

  public async validateEntryFiles(
    entryFiles: string[],
    rootDir: string,
    options: IAnalyzeOptions = {},
  ): Promise<string[]> {
    if (!this.isInitialized) {
      throw new ValidationError("DependencyAnalyzer not initialized");
    }

    this.logDebug(`Validating ${entryFiles.length} entry files in ${rootDir}`);

    const validationResult: IDependencyValidationResult = {
      isValid: true,
      validFiles: [],
      invalidFiles: [],
      errors: [],
    };

    let processed = 0;
    const total = entryFiles.length;

    for (const file of entryFiles) {
      try {
        const resolvedPath = this.deps.fileSystem.resolvePath(
          rootDir,
          file.trim(),
        );

        if (!this.deps.fileSystem.exists(resolvedPath)) {
          throw new ValidationError("Entry file not found", {
            file: resolvedPath,
          });
        }

        if (
          !options.includeNodeModules &&
          this.deps.ignoreHandler.shouldIgnore(resolvedPath)
        ) {
          throw new ValidationError("Entry file is ignored", {
            file: resolvedPath,
            ignorePatterns: this.deps.ignoreHandler.getPatterns(),
          });
        }

        validationResult.validFiles.push(resolvedPath);
        this.logDebug(`Validated entry file: ${resolvedPath}`);

        processed++;
        this.emitProgress("validation", processed, total, file);
      } catch (error) {
        validationResult.isValid = false;
        validationResult.invalidFiles.push(file);
        validationResult.errors.push({
          file,
          error: error instanceof Error ? error.message : String(error),
        });

        this.emit("warning", {
          message: `Failed to validate file: ${file}`,
          file,
          timestamp: Date.now(),
        });
      }
    }

    if (!validationResult.isValid) {
      this.handleError(
        "validate",
        new ValidationError("Entry file validation failed", {
          errors: validationResult.errors,
          invalidFiles: validationResult.invalidFiles,
        }),
      );
    }

    return validationResult.validFiles;
  }

  public async analyzeDependencies(
    entryFiles: string | string[],
    projectRoot: string,
    options: IAnalyzeOptions = {},
  ): Promise<IDependencyAnalysisResult> {
    if (!this.isInitialized) {
      throw new ValidationError("DependencyAnalyzer not initialized");
    }

    const startTime = Date.now();
    const files = Array.isArray(entryFiles) ? entryFiles : [entryFiles];

    this.logDebug(`Project root: ${projectRoot}`);
    this.logDebug(`Entry files: ${files.join(", ")}`);

    if (options.useWorkingDir) {
      this.changeWorkingDirectory(projectRoot);
    }

    try {
      this.emit("analysis:start", {
        entryFiles: files,
        timestamp: startTime,
      });

      // Convert entry files to absolute paths if they aren't already
      const absoluteFiles = files.map(file =>
        this.deps.fileSystem.isAbsolute(file)
          ? file
          : this.deps.fileSystem.resolvePath(projectRoot, file),
      );

      // Get relative paths for madge
      const relativeFiles = absoluteFiles.map(file =>
        this.deps.fileSystem.getRelativePath(projectRoot, file),
      );

      this.logDebug(`Analyzing dependencies for: ${relativeFiles.join(", ")}`);
      // Add the debug statements here
      this.logDebug(`Project root: ${projectRoot}`);
      this.logDebug(`Analyzing dependencies for: ${relativeFiles.join(", ")}`);
      this.logDebug(
        `Using TSConfig: ${this.deps.fileSystem.joinPath(
          projectRoot,
          this.tsConfigPath,
        )}`,
      );
      this.logDebug(`File extensions: ${this.fileExtensions.join(", ")}`);

      // Check cache if enabled
      if (!options.skipCache && this.deps.cache) {
        const cacheKey = this.getCacheKey(relativeFiles, projectRoot);
        const cachedDeps = this.deps.cache.get(cacheKey);

        if (cachedDeps) {
          const result = {
            entryFiles: absoluteFiles,
            dependencies: cachedDeps,
            circularDependencies:
              await this.getCircularDependencies(cachedDeps),
            totalFiles: Object.keys(cachedDeps).length,
            analysisTime: Date.now() - startTime,
          };

          this.logDebug("Returned cached dependency analysis");
          return result;
        }
      }

      const ignorePatterns = this.deps.ignoreHandler
        .getPatterns()
        .map(
          pattern =>
            new RegExp(
              pattern
                .replace(/\./g, "\\.")
                .replace(/\*\*/g, ".*")
                .replace(/\*/g, "[^/]*")
                .replace(/\?/g, "."),
            ),
        );

      const madgeConfig = {
        baseDir: projectRoot,
        tsConfig: this.deps.fileSystem.joinPath(projectRoot, this.tsConfigPath),
        fileExtensions: this.fileExtensions,
        excludeRegExp: options.includeNodeModules
          ? []
          : [/node_modules/, ...ignorePatterns],
        detectiveOptions: {
          ts: { mixedImports: true },
          tsx: { mixedImports: true },
        },
        followSymlinks: options.followSymlinks || false,
        cwd: projectRoot, // Add this line
        ...options.madgeConfig,
      };

      // Before calling madge, ensure we're in the right directory
      this.changeWorkingDirectory(projectRoot);

      // Process each entry file
      let processedFiles = 0;
      const dependencyMaps = await Promise.all(
        relativeFiles.map(async entryFile => {
          this.logDebug(`Processing dependencies for: ${entryFile}`);
          this.emitProgress(
            "analysis",
            ++processedFiles,
            relativeFiles.length,
            entryFile,
          );

          try {
            const madgeResult = await madge(entryFile, madgeConfig);
            return await madgeResult.obj();
          } catch (error) {
            this.deps.logger.error(
              `Failed to analyze dependencies for ${entryFile}: ${error}`,
            );
            throw error;
          }
        }),
      );

      const dependencies: IDependencyMap = {};
      let totalFiles = 0;

      dependencyMaps.forEach(deps => {
        Object.entries(deps).forEach(([file, fileDeps]) => {
          const absFile = this.deps.fileSystem.resolvePath(projectRoot, file);

          if (
            options.includeNodeModules ||
            !this.deps.ignoreHandler.shouldIgnore(absFile)
          ) {
            const validDeps = fileDeps
              .map(dep => this.deps.fileSystem.resolvePath(projectRoot, dep))
              .filter(
                dep =>
                  options.includeNodeModules ||
                  !this.deps.ignoreHandler.shouldIgnore(dep),
              );

            if (validDeps.length > 0) {
              dependencies[absFile] = Array.from(
                new Set([...(dependencies[absFile] || []), ...validDeps]),
              );
              totalFiles++;
            }
          }
        });
      });

      // Cache the result if enabled
      if (!options.skipCache && this.deps.cache) {
        const cacheKey = this.getCacheKey(relativeFiles, projectRoot);
        this.deps.cache.set(cacheKey, dependencies);
      }

      const circularDependencies =
        await this.getCircularDependencies(dependencies);

      const result: IDependencyAnalysisResult = {
        entryFiles: absoluteFiles,
        dependencies,
        circularDependencies,
        totalFiles,
        analysisTime: Date.now() - startTime,
        warnings:
          circularDependencies.length > 0
            ? [`Found ${circularDependencies.length} circular dependencies`]
            : undefined,
      };

      this.emit("analysis:complete", {
        result,
        timestamp: Date.now(),
      });

      this.logDebug(
        `Analysis complete: ${totalFiles} files, ` +
          `${circularDependencies.length} circular dependencies, ` +
          `${result.analysisTime}ms`,
      );

      return result;
    } catch (error) {
      this.handleError("analyze", error, {
        entryPoint: Array.isArray(entryFiles) ? entryFiles[0] : entryFiles,
        dependencies: Array.isArray(entryFiles) ? entryFiles : [entryFiles],
      });
    } finally {
      if (options.useWorkingDir) {
        this.restoreWorkingDirectory();
      }
    }
    // This return will never be reached because handleError always throws,
    // but TypeScript needs it to understand all paths return something
    return Promise.reject(new Error("Unreachable"));
  }

  public async gatherDependencies(
    adjacencyList: IDependencyMap,
    entryFiles: string[],
    maxDepth?: number,
  ): Promise<string[]> {
    if (!this.isInitialized) {
      throw new ValidationError("DependencyAnalyzer not initialized");
    }

    this.logDebug(
      `Gathering dependencies with max depth: ${maxDepth || "unlimited"}`,
    );

    const queue: Array<{ file: string; depth: number }> = [];
    const visited = new Set<string>();
    let processed = 0;
    const total = Object.keys(adjacencyList).length;

    for (const file of entryFiles) {
      if (!this.deps.ignoreHandler.shouldIgnore(file)) {
        queue.push({ file, depth: 0 });
        visited.add(file);
        this.logDebug(`Added entry file to queue: ${file}`);
      }
    }

    while (queue.length > 0) {
      const { file, depth } = queue.shift()!;
      if (maxDepth !== undefined && depth >= maxDepth) {
        this.logDebug(`Skipping ${file} - max depth (${maxDepth}) reached`);
        continue;
      }

      const children = adjacencyList[file] || [];
      for (const child of children) {
        if (
          !this.deps.ignoreHandler.shouldIgnore(child) &&
          !visited.has(child)
        ) {
          visited.add(child);
          queue.push({ file: child, depth: depth + 1 });
          this.logDebug(`Added dependency: ${child} (depth: ${depth + 1})`);
        }
      }

      processed++;
      this.emitProgress("gathering", processed, total, file);
    }

    const result = Array.from(visited);

    this.logDebug(`Gathered ${result.length} total dependencies`);

    // Filter out empty files
    const nonEmptyFiles = await Promise.all(
      result.map(async filePath => {
        try {
          const content = await this.deps.fileSystem.readFile(filePath);
          return content.trim() !== "" ? filePath : null;
        } catch (error) {
          this.deps.logger.warn(`Error reading file ${filePath}: ${error}`);
          return null;
        }
      }),
    );

    return nonEmptyFiles.filter((file): file is string => file !== null);
  }

  public async getCircularDependencies(
    dependencyMap: IDependencyMap,
  ): Promise<string[][]> {
    this.logDebug("Analyzing circular dependencies");

    const visited = new Set<string>();
    const recursionStack = new Set<string>();
    const cycles: string[][] = [];

    const dfs = (node: string, path: string[] = []): void => {
      visited.add(node);
      recursionStack.add(node);
      path.push(node);

      const dependencies = dependencyMap[node] || [];
      for (const dependency of dependencies) {
        if (!visited.has(dependency)) {
          dfs(dependency, [...path]);
        } else if (recursionStack.has(dependency)) {
          const cycleStart = path.indexOf(dependency);
          const cycle = path.slice(cycleStart);
          if (
            !cycles.some(
              existing =>
                existing.length === cycle.length &&
                existing.every((value, index) => value === cycle[index]),
            )
          ) {
            cycles.push(cycle);
            this.emit("warning", {
              message: `Found circular dependency: ${cycle.join(" -> ")}`,
              timestamp: Date.now(),
            });
          }
        }
      }

      recursionStack.delete(node);
      path.pop();
    };

    for (const node of Object.keys(dependencyMap)) {
      if (!visited.has(node)) {
        dfs(node);
      }
    }

    if (cycles.length > 0) {
      this.logDebug(`Found ${cycles.length} circular dependencies`);
      cycles.forEach((cycle, index) => {
        this.logDebug(`Cycle ${index + 1}: ${cycle.join(" -> ")}`);
      });
    }

    return cycles;
  }

  private getCacheKey(relativeFiles: string[], projectRoot: string): string {
    const content = JSON.stringify({
      files: relativeFiles.sort(), // Sort for consistent keys
      root: projectRoot,
      extensions: this.fileExtensions,
      config: {
        tsConfig: this.tsConfigPath,
        webpackConfig: this.webpackConfigPath,
      },
    });

    return require("crypto").createHash("md5").update(content).digest("hex");
  }
}

================
File: src/core/dependency/DependencyCache.ts
================
// src/core/dependency/DependencyCache.ts

import { CacheError } from "@/errors";
import {
  IDependencyCache,
  IDependencyCacheEntry,
  IDependencyCacheStats,
  IDependencyCacheDeps,
  IDependencyCacheOptions,
  ICacheOperationOptions,
} from "./interfaces/IDependencyCache";
import { IDependencyMap } from "dependency";

export class DependencyCache implements IDependencyCache {
  private cache: Map<string, IDependencyCacheEntry>;
  private readonly debug: boolean;
  private readonly timeout: number;
  private stats: IDependencyCacheStats;
  isInitialized: boolean = false;
  private cacheDuration: number;

  constructor(
    private readonly deps: IDependencyCacheDeps,
    options: IDependencyCacheOptions = {},
  ) {
    this.debug = options.debug || false;
    this.timeout = options.timeout || 5 * 60 * 1000; // 5 minutes default
    this.cache = new Map();
    this.stats = {
      size: 0,
      hits: 0,
      misses: 0,
      oldestEntry: null,
      averageAge: 0,
      invalidations: 0,
      errors: 0,
    };
    this.cacheDuration = 0;
  }

  private initializeStats(): void {
    this.stats = {
      size: 0,
      hits: 0,
      misses: 0,
      oldestEntry: null,
      averageAge: 0,
      invalidations: 0,
      errors: 0,
    };
  }

  public async initialize(options: ICacheOperationOptions = {}): Promise<void> {
    this.logDebug("Initializing DependencyCache");

    try {
      if (this.isInitialized) {
        this.logDebug("DependencyCache already initialized");
        return;
      }
      
      if (options.force) {
        this.cache.clear();
        this.logDebug("Forced cache clear during initialization");
      }
      
      if (options.timeout) {
        this.cacheDuration = options.timeout;
        this.logDebug(`Cache timeout set to ${options.timeout}ms`);
      }

      this.cache.clear();
      this.initializeStats();
      this.isInitialized = true;
      this.logDebug("DependencyCache initialization complete");
    } catch (error) {
      throw new CacheError(
        `Failed to initialize cache: ${error instanceof Error ? error.message : String(error)}`,
        "initialize",
      );
    }
  }

  public cleanup(): void {
    this.logDebug("Cleaning up DependencyCache");
    this.cache.clear();
    this.initializeStats();
    this.isInitialized = false;
  }

  private logDebug(message: string): void {
    if (this.debug) {
      this.deps.logger.debug(message);
    }
  }

  private handleError(operation: string, error: unknown, key?: string): never {
    const message = error instanceof Error ? error.message : String(error);
    const cacheError = new CacheError(
      `Cache ${operation} failed: ${message}`,
      operation as "read" | "write" | "delete" | "clear",
      key,
    );
    this.stats.errors++;
    this.deps.logger.error(cacheError.message);
    throw cacheError;
  }

  public get(
    key: string,
    options: ICacheOperationOptions = {},
  ): IDependencyMap | null {
    if (!this.isInitialized) {
      throw new CacheError("Cache not initialized", "read");
    }

    this.logDebug(`Getting cache entry for key: ${key}`);

    try {
      const entry = this.cache.get(key);
      if (!entry) {
        this.stats.misses++;
        this.logDebug(`Cache miss for key: ${key}`);
        return null;
      }

      const age = Date.now() - entry.timestamp;
      if (age > (options.timeout || this.timeout)) {
        this.cache.delete(key);
        this.stats.invalidations++;
        this.stats.misses++;
        this.logDebug(`Cache entry expired for key: ${key}`);
        return null;
      }

      this.stats.hits++;
      this.logDebug(`Cache hit for key: ${key}`);
      return entry.dependencies;
    } catch (error) {
      this.handleError("read", error, key);
    }
  }

  public set(
    key: string,
    dependencies: IDependencyMap,
    options: ICacheOperationOptions = {},
  ): void {
    if (!this.isInitialized) {
      throw new CacheError("Cache not initialized", "write");
    }
    this.logDebug(`Setting cache entry for key: ${key}`);
  
    try {
      const entry: IDependencyCacheEntry = {
        dependencies,
        timestamp: Date.now(),
        hash: this.computeHash(dependencies),
        timeout: options.timeout || this.cacheDuration
      };
  
      if (options.force) {
        this.logDebug(`Force writing cache entry for ${key}`);
        this.cache.set(key, entry);
      } else if (!this.cache.has(key)) {
        this.cache.set(key, entry);
      }
  
      this.updateStats();
      this.logDebug(`Cache entry set for key: ${key}`);
    } catch (error) {
      this.handleError("write", error, key);
    }
  }

  public delete(key: string): void {
    if (!this.isInitialized) {
      throw new CacheError("Cache not initialized", "delete");
    }

    this.logDebug(`Deleting cache entry for key: ${key}`);

    try {
      const deleted = this.cache.delete(key);
      if (deleted) {
        this.updateStats();
        this.logDebug(`Cache entry deleted for key: ${key}`);
      }
    } catch (error) {
      this.handleError("delete", error, key);
    }
  }

  public clear(): void {
    if (!this.isInitialized) {
      throw new CacheError("Cache not initialized", "clear");
    }

    this.logDebug("Clearing cache");

    try {
      this.cache.clear();
      this.initializeStats();
      this.logDebug("Cache cleared");
    } catch (error) {
      this.handleError("clear", error);
    }
  }

  public has(key: string): boolean {
    if (!this.isInitialized) {
      throw new CacheError("Cache not initialized", "read");
    }

    const entry = this.cache.get(key);
    if (!entry) return false;

    const age = Date.now() - entry.timestamp;
    if (age > this.timeout) {
      this.cache.delete(key);
      this.stats.invalidations++;
      return false;
    }

    return true;
  }

  private computeHash(dependencies: IDependencyMap): string {
    return JSON.stringify(dependencies);
  }

  private updateStats(): void {
    const entries = Array.from(this.cache.values());
    let oldestTimestamp = Date.now();
    let totalAge = 0;

    entries.forEach(entry => {
      const age = Date.now() - entry.timestamp;
      oldestTimestamp = Math.min(oldestTimestamp, entry.timestamp);
      totalAge += age;
    });

    this.stats = {
      ...this.stats,
      size: this.cache.size,
      oldestEntry: this.cache.size > 0 ? oldestTimestamp : null,
      averageAge: this.cache.size > 0 ? totalAge / this.cache.size : 0,
    };
  }

  public getStats(): IDependencyCacheStats {
    this.updateStats();
    return { ...this.stats };
  }
}

================
File: src/core/dependency/IgnoreHandler.ts
================
// src/core/dependency/IgnoreHandler.ts

import micromatch from "micromatch";
import { FileSystemError, ValidationError } from "@/errors";
import {
  IIgnoreHandler,
  IIgnoreHandlerDeps,
  IIgnoreHandlerOptions,
  IIgnorePatternValidator,
  IPatternValidationResult,
  ILoadPatternsOptions,
} from "./interfaces/IIgnoreHandler";
import { BaseService } from "@/types/services";

export class IgnoreHandler
  extends BaseService
  implements IIgnoreHandler, IIgnorePatternValidator
{
  private patterns: string[] = [];
  private readonly projectRoot: string;
  private readonly debug: boolean;

  constructor(
    projectRoot: string,
    private readonly deps: IIgnoreHandlerDeps,
    options: IIgnoreHandlerOptions = {},
  ) {
    super();
    if (!projectRoot || typeof projectRoot !== "string") {
      throw new ValidationError("Invalid project root", { projectRoot });
    }

    this.projectRoot = projectRoot;
    this.debug = options.debug || false;

    // Defer pattern loading to initialize()
    if (options.extraPatterns) {
      this.logDebug(`Received ${options.extraPatterns.length} extra patterns`);
      this.patterns = [...options.extraPatterns];
    }
  }

  public override async initialize(): Promise<void> {
    await super.initialize();
    this.logDebug("Initializing IgnoreHandler");

    try {
      if (!this.deps.fileSystem.exists(this.projectRoot)) {
        throw new ValidationError("Project root does not exist", {
          projectRoot: this.projectRoot,
        });
      }

      await this.loadIgnorePatterns();
      this.logDebug("IgnoreHandler initialization complete");
    } catch (error) {
      throw new ValidationError(
        `Failed to initialize IgnoreHandler: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  public override cleanup(): void {
    this.logDebug("Cleaning up IgnoreHandler");
    this.patterns = [];
    super.cleanup();
  }

  private logDebug(message: string): void {
    if (this.debug) {
      this.deps.logger.debug(message);
    }
  }

  private async loadIgnorePatterns(
    options: ILoadPatternsOptions = {},
  ): Promise<void> {
    const gatherTSIgnorePath = this.deps.fileSystem.joinPath(
      this.projectRoot,
      ".gather-ts-ignore",
    );
    const gitignorePath = this.deps.fileSystem.joinPath(
      this.projectRoot,
      ".gitignore",
    );

    try {
      this.logDebug("Loading ignore patterns");

      // Load patterns from both files
      const gatherTSPatterns = await this.loadIgnoreFile(gatherTSIgnorePath);
      const gitignorePatterns = options.skipGitignore
        ? []
        : await this.loadIgnoreFile(gitignorePath);

      // Process patterns from each source
      const processedGatherTSPatterns = this.processPatterns(
        gatherTSPatterns,
        ".gather-ts-ignore",
      );
      const processedGitignorePatterns = this.processPatterns(
        gitignorePatterns,
        ".gitignore",
      );

      // Combine all patterns
      const defaultPatterns = ["node_modules/**", ".git/**"];
      this.patterns = [
        ...defaultPatterns,
        ...processedGatherTSPatterns,
        ...processedGitignorePatterns,
        ...this.patterns, // Keep any extra patterns added in constructor
      ];

      // Remove duplicates while preserving order
      this.patterns = [...new Set(this.patterns)];

      if (gatherTSPatterns.length > 0 || gitignorePatterns.length > 0) {
        this.deps.logger.info("\nLoaded ignore patterns from:");
        if (gatherTSPatterns.length > 0) {
          this.deps.logger.info(
            `- .gather-ts-ignore (${gatherTSPatterns.length} patterns)`,
          );
        }
        if (gitignorePatterns.length > 0) {
          this.deps.logger.info(
            `- .gitignore (${gitignorePatterns.length} patterns)`,
          );
        }
      }

      this.logDebug(`Total patterns loaded: ${this.patterns.length}`);
    } catch (error) {
      if (error instanceof ValidationError) {
        throw error;
      }
      throw new ValidationError(
        `Failed to load ignore patterns: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  private async loadIgnoreFile(filePath: string): Promise<string[]> {
    try {
      if (!this.deps.fileSystem.exists(filePath)) {
        this.logDebug(`Ignore file not found: ${filePath}`);
        return [];
      }

      const content = await this.deps.fileSystem.readFile(filePath, {
        encoding: "utf8",
      });
      const patterns = content
        .split("\n")
        .map(line => line.trim())
        .filter(line => line && !line.startsWith("#"));

      this.logDebug(`Loaded ${patterns.length} patterns from ${filePath}`);
      return patterns;
    } catch (error) {
      throw new FileSystemError(
        `Failed to read ignore file: ${error instanceof Error ? error.message : String(error)}`,
        filePath,
        "read",
      );
    }
  }

  public validatePattern(pattern: string): string {
    if (typeof pattern !== "string") {
      throw new ValidationError("Invalid ignore pattern", { pattern });
    }

    // Remove any leading ./ from the pattern
    pattern = pattern.replace(/^\.\//, "");

    // Validate pattern syntax
    try {
      micromatch(["test"], pattern);
      return pattern;
    } catch (error) {
      throw new ValidationError(
        `Invalid ignore pattern syntax: ${error instanceof Error ? error.message : String(error)}`,
        { pattern },
      );
    }
  }

  public parsePattern(pattern: string): IPatternValidationResult {
    try {
      const normalizedPattern = this.validatePattern(pattern);
      return {
        isValid: true,
        normalizedPattern,
      };
    } catch (error) {
      return {
        isValid: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  public validatePatterns(patterns: string[]): string[] {
    this.logDebug(`Validating ${patterns.length} patterns`);

    const validPatterns: string[] = [];
    const errors: string[] = [];

    patterns.forEach(pattern => {
      const result = this.parsePattern(pattern);
      if (result.isValid && result.normalizedPattern) {
        validPatterns.push(result.normalizedPattern);
      } else {
        errors.push(`Invalid pattern "${pattern}": ${result.error}`);
      }
    });

    if (errors.length > 0) {
      throw new ValidationError("Invalid patterns found", { errors });
    }

    return validPatterns;
  }

  private processPatterns(patterns: string[], source: string): string[] {
    this.logDebug(`Processing patterns from ${source}`);

    try {
      return patterns.reduce((acc: string[], pattern: string) => {
        pattern = this.validatePattern(pattern);

        // Don't modify negation patterns
        if (pattern.startsWith("!")) {
          acc.push(pattern);
          return acc;
        }

        // For directory patterns ending with /, add the directory and its contents
        if (pattern.endsWith("/")) {
          acc.push(pattern);
          acc.push(`${pattern}**`);
          return acc;
        }

        // For patterns that already have globs or path separators, add as-is
        if (pattern.includes("*") || pattern.includes("/")) {
          acc.push(pattern);
          return acc;
        }

        // For simple patterns, add both the exact match and the **/ version
        acc.push(pattern);
        acc.push(`**/${pattern}`);

        return acc;
      }, []);
    } catch (error) {
      throw new ValidationError(
        `Failed to process patterns from ${source}: ${error instanceof Error ? error.message : String(error)}`,
        { source, patterns },
      );
    }
  }

  public shouldIgnore(filePath: string): boolean {
    if (!this.isInitialized) {
      throw new ValidationError("IgnoreHandler not initialized");
    }

    this.validateFilePath(filePath);

    try {
      const relativePath = this.deps.fileSystem
        .getRelativePath(this.projectRoot, filePath)
        .split(this.deps.fileSystem.getDirName("/"))
        .join("/");

      if (relativePath.includes("node_modules")) {
        return true;
      }

      this.logDebug(`Checking '${relativePath}'...`);

      let lastMatchedPattern: string | null = null;
      let wasNegated = false;

      for (const pattern of this.patterns) {
        try {
          const isMatch = micromatch.isMatch(relativePath, pattern, {
            dot: true,
            matchBase: true,
          });

          if (isMatch) {
            lastMatchedPattern = pattern;
            if (pattern.startsWith("!")) {
              wasNegated = true;
              this.logDebug(`File included by negation pattern: '${pattern}'`);
              return false;
            }
            this.logDebug(`File will be ignored due to pattern: '${pattern}'`);
            return true;
          }
        } catch (error) {
          this.deps.logger.warn(
            `Pattern matching error for '${pattern}': ${error instanceof Error ? error.message : String(error)}`,
          );
          continue;
        }
      }

      if (lastMatchedPattern) {
        this.logDebug(
          wasNegated
            ? `File included by negation pattern: '${lastMatchedPattern}'`
            : `File matched pattern: '${lastMatchedPattern}'`,
        );
      }

      return false;
    } catch (error) {
      throw new ValidationError(
        `Error checking ignore status: ${error instanceof Error ? error.message : String(error)}`,
        { filePath },
      );
    }
  }

  public validateFilePath(filePath: string): void {
    if (!filePath) {
      throw new ValidationError("Empty file path provided");
    }

    try {
      const absolutePath = this.deps.fileSystem.resolvePath(
        this.deps.fileSystem.isAbsolute(filePath) ? "" : this.projectRoot,
        filePath,
      );

      if (!this.deps.fileSystem.exists(absolutePath)) {
        throw new ValidationError("File does not exist", {
          filePath: absolutePath,
        });
      }

      if (!this.deps.fileSystem.isReadable(absolutePath)) {
        throw new ValidationError("File is not readable", {
          filePath: absolutePath,
        });
      }
    } catch (error) {
      if (error instanceof ValidationError) {
        throw error;
      }
      throw new ValidationError(
        `Failed to validate file path: ${error instanceof Error ? error.message : String(error)}`,
        { filePath },
      );
    }
  }

  public getPatterns(): string[] {
    return [...this.patterns];
  }

  public addPattern(pattern: string): void {
    this.logDebug(`Adding pattern: ${pattern}`);

    try {
      const validatedPattern = this.validatePattern(pattern);
      if (!this.patterns.includes(validatedPattern)) {
        this.patterns.push(validatedPattern);
        this.logDebug(`Added pattern: ${validatedPattern}`);
      }
    } catch (error) {
      throw new ValidationError(
        `Failed to add ignore pattern: ${error instanceof Error ? error.message : String(error)}`,
        { pattern },
      );
    }
  }

  public removePattern(pattern: string): boolean {
    this.logDebug(`Removing pattern: ${pattern}`);

    const index = this.patterns.indexOf(pattern);
    if (index !== -1) {
      this.patterns.splice(index, 1);
      this.logDebug(`Removed pattern: ${pattern}`);
      return true;
    }
    return false;
  }

  public resetPatterns(): void {
    this.logDebug("Resetting patterns to defaults");
    this.patterns = ["node_modules/**", ".git/**"];
  }

  public printDebugInfo(filePath: string): void {
    try {
      this.validateFilePath(filePath);

      const relativePath = this.deps.fileSystem
        .getRelativePath(this.projectRoot, filePath)
        .split(this.deps.fileSystem.getDirName("/"))
        .join("/");

      this.deps.logger.debug("\nDebug Information:");
      this.deps.logger.debug("----------------");
      this.deps.logger.debug(`File: ${relativePath}`);
      this.deps.logger.debug(`Project Root: ${this.projectRoot}`);
      this.deps.logger.debug("\nTesting patterns:");

      const matchResults = this.patterns.map(pattern => {
        try {
          const isMatch = micromatch.isMatch(relativePath, pattern, {
            dot: true,
            matchBase: true,
          });
          return {
            pattern,
            isMatch,
            error: null,
          };
        } catch (error) {
          return {
            pattern,
            isMatch: false,
            error: error instanceof Error ? error.message : String(error),
          };
        }
      });

      matchResults.forEach(({ pattern, isMatch, error }) => {
        if (error) {
          this.deps.logger.debug(`! ERROR: ${pattern} - ${error}`);
        } else {
          this.deps.logger.debug(`${isMatch ? "‚úì" : "‚úó"} ${pattern}`);
        }
      });

      const negationPatterns = matchResults.filter(
        ({ pattern, isMatch }) => pattern.startsWith("!") && isMatch,
      );

      if (negationPatterns.length > 0) {
        this.deps.logger.debug("\nNegation patterns matched:");
        negationPatterns.forEach(({ pattern }) => {
          this.deps.logger.debug(`! ${pattern}`);
        });
      }

      const isIgnored = this.shouldIgnore(filePath);
      this.deps.logger.debug("\nFinal result:");
      this.deps.logger.debug(
        `File will be ${isIgnored ? "IGNORED" : "INCLUDED"}`,
      );
    } catch (error) {
      throw new ValidationError(
        `Failed to print debug info: ${error instanceof Error ? error.message : String(error)}`,
        { filePath },
      );
    }
  }
}

================
File: src/core/dependency/index.ts
================
// src/core/dependency/index.ts
export * from "./DependencyAnalyzer";
export * from "./DependencyCache";
export * from "./IgnoreHandler";
export * from "./interfaces/IDependencyAnalyzer";
export * from "./interfaces/IDependencyCache";
export * from "./interfaces/IIgnoreHandler";

================
File: src/core/dependency/interfaces/IDependencyAnalyzer.ts
================
// src/core/dependency/interfaces/IDependencyAnalyzer.ts

import { IService } from "@/types/services";
import { IFileSystem } from "@/utils/filesystem/interfaces/IFileSystem";
import { ILogger } from "@/utils/logging/interfaces/ILogger";
import { IIgnoreHandler } from "./IIgnoreHandler";
import { IDependencyCache } from "./IDependencyCache";
import { EventEmitter } from "events";
import { IDependencyMap } from "dependency";

export interface IDependencyAnalyzerDeps {
  fileSystem: IFileSystem;
  logger: ILogger;
  ignoreHandler: IIgnoreHandler;
  cache?: IDependencyCache;
}

export interface IDependencyAnalyzerOptions {
  debug?: boolean;
  webpackConfigPath?: string;
  tsConfigPath?: string;
  fileExtensions?: string[];
  maxConcurrency?: number;
}

export interface IAnalyzeOptions {
  skipCache?: boolean;
  useWorkingDir?: boolean;
  madgeConfig?: Record<string, unknown>;
  includeNodeModules?: boolean;
  followSymlinks?: boolean;
  maxDepth?: number;
}

export interface IDependencyValidationResult {
  isValid: boolean;
  validFiles: string[];
  invalidFiles: string[];
  errors: Array<{
    file: string;
    error: string;
  }>;
}

export interface IDependencyAnalysisResult {
  entryFiles: string[];
  dependencies: IDependencyMap;
  circularDependencies: string[][];
  totalFiles: number;
  analysisTime: number;
  warnings?: string[];
}

export interface IDependencyProgress {
  phase: "validation" | "analysis" | "gathering";
  completed: number;
  total: number;
  currentFile?: string;
}

export interface IDependencyAnalyzerEvents {
  "analysis:start": { entryFiles: string[]; timestamp: number };
  "analysis:complete": { result: IDependencyAnalysisResult; timestamp: number };
  "analysis:error": { error: Error; phase: string; timestamp: number };
  progress: IDependencyProgress;
  warning: { message: string; file?: string; timestamp: number };
}

export interface IDependencyAnalyzer extends IService, EventEmitter {
  validateEntryFiles(
    entryFiles: string[],
    rootDir: string,
    options?: IAnalyzeOptions,
  ): Promise<string[]>;

  analyzeDependencies(
    entryFiles: string | string[],
    projectRoot: string,
    options?: IAnalyzeOptions,
  ): Promise<IDependencyAnalysisResult>;

  gatherDependencies(
    deps: IDependencyMap,
    entryFiles: string[],
    maxDepth?: number,
  ): Promise<string[]>;

  getCircularDependencies(dependencyMap: IDependencyMap): Promise<string[][]>;

  on<K extends keyof IDependencyAnalyzerEvents>(
    event: K,
    listener: (data: IDependencyAnalyzerEvents[K]) => void,
  ): this;

  off<K extends keyof IDependencyAnalyzerEvents>(
    event: K,
    listener: (data: IDependencyAnalyzerEvents[K]) => void,
  ): this;

  emit<K extends keyof IDependencyAnalyzerEvents>(
    event: K,
    data: IDependencyAnalyzerEvents[K],
  ): boolean;
}

================
File: src/core/dependency/interfaces/IDependencyCache.ts
================
// src/core/dependency/interfaces/IDependencyCache.ts

import { IService } from "@/types/services";
import { ILogger } from "@/utils/logging/interfaces/ILogger";
import { IDependencyMap } from "dependency";

export interface IDependencyCacheDeps {
  logger: ILogger;
}

export interface IDependencyCacheOptions {
  debug?: boolean;
  timeout?: number;
}

export interface ICacheOperationOptions {
  timeout?: number;
  force?: boolean;
}

export interface IDependencyCacheEntry {
  dependencies: IDependencyMap;
  timestamp: number;
  hash: string;
  timeout: number;
}

export interface IDependencyCacheStats {
  size: number;
  hits: number;
  misses: number;
  oldestEntry: number | null;
  averageAge: number;
  invalidations: number;
  errors: number;
}

export interface IDependencyCache extends IService {
  get(key: string, options?: ICacheOperationOptions): IDependencyMap | null;
  set(
    key: string,
    dependencies: IDependencyMap,
    options?: ICacheOperationOptions,
  ): void;
  delete(key: string): void;
  clear(): void;
  has(key: string): boolean;
  getStats(): IDependencyCacheStats;
}

================
File: src/core/dependency/interfaces/IIgnoreHandler.ts
================
// src/core/dependency/interfaces/IIgnoreHandler.ts

import { IFileSystem } from "@/utils/filesystem/interfaces/IFileSystem";
import { ILogger } from "@/utils/logging/interfaces/ILogger";
import { IService } from "@/types/services";

export interface IIgnoreHandlerDeps {
  fileSystem: IFileSystem;
  logger: ILogger;
}

export interface IIgnoreHandlerOptions {
  debug?: boolean;
  extraPatterns?: string[];
}

export interface ILoadPatternsOptions {
  skipGitignore?: boolean;
  validate?: boolean;
}

export interface IIgnoreHandler extends IService {
  // Core functionality
  shouldIgnore(filePath: string): boolean;
  validateFilePath(filePath: string): void;

  // Pattern management
  getPatterns(): string[];
  addPattern(pattern: string): void;
  removePattern(pattern: string): boolean;
  resetPatterns(): void;

  // Debug utilities
  printDebugInfo(filePath: string): void;

  // Lifecycle methods
  initialize(): Promise<void>;
  cleanup(): void;
}

export interface IPatternValidationResult {
  isValid: boolean;
  normalizedPattern?: string;
  error?: string;
}

export interface IIgnorePatternValidator {
  validatePattern(pattern: string): string;
  parsePattern(pattern: string): IPatternValidationResult;
  validatePatterns(patterns: string[]): string[];
}

================
File: src/core/templating/DefaultTemplates.ts
================
// src/core/templating/defaultTemplates.ts

import { ITemplate, ITemplateManager } from "./interfaces/ITemplateManager";

export const defaultTemplates: ITemplate[] = [
  {
    id: "mainHeader",
    description: "Main document header with title and description",
    content: `# Project Code Analysis
This file contains a comprehensive analysis of the project's codebase.
Prepared for AI-assisted code review and analysis.

This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by {{tool}} on: {{date}}`,
    variables: [
      { name: "tool", description: "Tool name", required: true },
      { name: "date", description: "Generation date", required: true },
    ],
  },
  {
    id: "fileSummary",
    description: "File summary section with purpose and format",
    content: `
================================================================
File Summary
================================================================
Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and {{tool}}'s
  configuration.
- Binary files are not included in this packed representation.
{{customNotes}}`,
    variables: [
      { name: "tool", description: "Tool name", required: true },
      {
        name: "customNotes",
        description: "Additional notes",
        required: false,
        defaultValue: "",
      },
    ],
  },
  {
    id: "repositoryStructure",
    description: "Repository structure section with file list",
    content: `
================================================================
Repository Structure
================================================================
{{fileList}}`,
    variables: [
      {
        name: "fileList",
        description: "List of files in repository",
        required: true,
      },
    ],
  },
  {
    id: "repositoryFiles",
    description: "Repository files section header",
    content: `
================================================================
Repository Files
================================================================
## File Contents
Each file is presented with its full content for detailed analysis.`,
    variables: [],
  },
  {
    id: "fileEntry",
    description: "Individual file entry template",
    content: `
================
File: {{filePath}}
================
{{fileContent}}`,
    variables: [
      { name: "filePath", description: "Path to the file", required: true },
      {
        name: "fileContent",
        description: "Content of the file",
        required: true,
      },
    ],
  },
];

// Helper function to register all default templates
export function registerDefaultTemplates(
  templateManager: ITemplateManager,
): void {
  try {
    defaultTemplates.forEach(template => {
      if (!templateManager.hasTemplate(template.id)) {
        templateManager.registerTemplate(template);
      }
    });
  } catch (error) {
    throw new Error(
      `Failed to register default templates: ${error instanceof Error ? error.message : String(error)}`,
    );
  }
}

// Import types needed in implementation
/*
private async generateOutput(
  filesWithContent: IFileWithContent[],
  configManager: IConfigManager,
  maxDepth?: number
): Promise<string> {
  const generationTime = new Date().toISOString();
  const output: string[] = [];

  // Add main header
  output.push(this.deps.templateManager.render('mainHeader', {
    tool: 'gather-ts',
    date: generationTime
  }));

  // Add file summary
  output.push(this.deps.templateManager.render('fileSummary', {
    tool: 'gather-ts',
    customNotes: configManager.getConfig().customText?.beforeSummary || ''
  }));

  // Add repository structure
  const fileList = filesWithContent
    .map(file => file.path)
    .join('\n');
  output.push(this.deps.templateManager.render('repositoryStructure', {
    fileList
  }));

  // Add repository files header
  output.push(this.deps.templateManager.render('repositoryFiles', {}));

  // Add each file
  for (const file of filesWithContent) {
    output.push(this.deps.templateManager.render('fileEntry', {
      filePath: file.path,
      fileContent: file.content
    }));
  }

  return output.join('\n');
}
*/

================
File: src/core/templating/index.ts
================
export * from './DefaultTemplates'
export * from './TemplateManager'
export * from './interfaces/ITemplateManager'

================
File: src/core/templating/interfaces/ITemplateManager.ts
================
// src/core/templating/interfaces/ITemplateManager.ts
import { IService } from "@/types/services";
import { ILogger } from "@/utils/logging/interfaces/ILogger";

export interface ITemplateVariable {
  name: string;
  description: string;
  required: boolean;
  defaultValue?: string;
}

export interface ITemplate {
  id: string;
  content: string;
  variables: ITemplateVariable[];
  description?: string;
}

export interface ITemplateContext {
  [key: string]: string;
}

export interface ITemplateManagerDeps {
  logger: ILogger;
}

export interface ITemplateManagerOptions {
  debug?: boolean;
}

export interface ITemplateManager extends IService {
  registerTemplate(template: ITemplate): void;
  getTemplate(id: string): ITemplate;
  render(templateId: string, context: ITemplateContext): string;
  hasTemplate(id: string): boolean;
}

================
File: src/core/templating/TemplateManager.ts
================
// src/core/templating/TemplateManager.ts
import { ValidationError } from "@/errors";
import { BaseService } from "@/types/services";
import {
  ITemplateManager,
  ITemplateManagerDeps,
  ITemplateManagerOptions,
  ITemplate,
  ITemplateContext,
} from "./interfaces/ITemplateManager";

export class TemplateManager extends BaseService implements ITemplateManager {
  private templates: Map<string, ITemplate> = new Map();
  private readonly debug: boolean;

  constructor(
    private readonly deps: ITemplateManagerDeps,
    options: ITemplateManagerOptions = {},
  ) {
    super();
    this.debug = options.debug || false;
  }

  public override async initialize(): Promise<void> {
    await super.initialize();
    this.logDebug("Initializing TemplateManager");
  }

  public override cleanup(): void {
    this.logDebug("Cleaning up TemplateManager");
    this.templates.clear();
    super.cleanup();
  }

  private logDebug(message: string): void {
    if (this.debug) {
      this.deps.logger.debug(`[TemplateManager] ${message}`);
    }
  }

  public registerTemplate(template: ITemplate): void {
    this.checkInitialized();

    if (this.templates.has(template.id)) {
      throw new ValidationError(
        `Template with ID ${template.id} already exists`,
      );
    }

    this.validateTemplate(template);
    this.templates.set(template.id, template);
    this.logDebug(`Registered template: ${template.id}`);
  }

  public getTemplate(id: string): ITemplate {
    this.checkInitialized();

    const template = this.templates.get(id);
    if (!template) {
      throw new ValidationError(`Template with ID ${id} not found`);
    }
    return template;
  }

  public hasTemplate(id: string): boolean {
    return this.templates.has(id);
  }

  public render(templateId: string, context: ITemplateContext): string {
    this.checkInitialized();

    const template = this.getTemplate(templateId);
    this.validateContext(template, context);
    const fullContext = this.applyDefaults(template, context);

    const result = this.renderTemplate(template.content, fullContext);
    this.logDebug(`Rendered template: ${templateId}`);

    return result;
  }

  private validateTemplate(template: ITemplate): void {
    if (!template.id || !template.content) {
      throw new ValidationError("Template must have id and content");
    }

    const declaredVars = new Set(template.variables.map(v => v.name));
    const usedVars = this.extractVariables(template.content);

    const undeclaredVars = [...usedVars].filter(v => !declaredVars.has(v));
    if (undeclaredVars.length > 0) {
      throw new ValidationError(
        `Template contains undeclared variables: ${undeclaredVars.join(", ")}`,
      );
    }
  }

  private validateContext(
    template: ITemplate,
    context: ITemplateContext,
  ): void {
    const requiredVars = template.variables.filter(v => v.required);

    for (const variable of requiredVars) {
      if (!(variable.name in context)) {
        throw new ValidationError(
          `Missing required variable: ${variable.name}`,
        );
      }
    }
  }

  private applyDefaults(
    template: ITemplate,
    context: ITemplateContext,
  ): ITemplateContext {
    const result = { ...context };

    for (const variable of template.variables) {
      if (!(variable.name in result) && variable.defaultValue !== undefined) {
        result[variable.name] = variable.defaultValue;
      }
    }

    return result;
  }

  private extractVariables(content: string): Set<string> {
    const varRegex = /\{\{([\w.-]+)\}\}/g;
    const variables = new Set<string>();
    let match;

    while ((match = varRegex.exec(content)) !== null) {
      variables.add(match[1]);
    }

    return variables;
  }

  private renderTemplate(content: string, context: ITemplateContext): string {
    return content.replace(/\{\{([\w.-]+)\}\}/g, (_, key) => {
      return context[key] || "";
    });
  }
}

================
File: src/core/tokenization/index.ts
================
export * from "./TokenCounter";
export * from "./TokenCache";
export * from "./interfaces/ITokenCounter";
export * from "./interfaces/ITokenCache";

================
File: src/core/tokenization/interfaces/ITokenCache.ts
================
// src/core/tokenization/interfaces/ITokenCache.ts

import { ILogger } from "@/utils";
import { IFileSystem } from "@/utils/filesystem/interfaces/IFileSystem";
import { IService } from "@/types/services";

export interface ICacheEntry {
  hash: string;
  tokens: number;
  lastUpdated: string;
}

export interface ITokenCacheDeps {
  fileSystem: IFileSystem;
  logger: ILogger;
}

export interface ITokenCacheOptions {
  maxCacheAge?: number;
  debug?: boolean;
}

export interface ITokenCache extends IService {
  getCachedTokenCount(filePath: string, content: string): number | null;
  cacheTokenCount(filePath: string, content: string, tokens: number): void;
  clear(): void;
  getCacheStats(): ICacheStats;
}

export interface ICacheStats {
  totalEntries: number;
  oldestEntry: string | null;
  newestEntry: string | null;
  totalSize: number;
  hitCount: number;
  missCount: number;
  invalidations: number;
}

================
File: src/core/tokenization/interfaces/ITokenCounter.ts
================
// src/core/tokenization/interfaces/ITokenCounter.ts

import { IFileWithContent } from "@/types/files";
import { ISummaryStats } from "@/types/stats";
import { IConfigManager } from "@/config";
import { IFileSystem } from "@/utils/filesystem/interfaces/IFileSystem";
import { ILogger } from "@/utils/logging/interfaces/ILogger";
import { IService } from "@/types/services";
import { TiktokenModel } from "@/types/models/tokenizer";
import { ITokenCache } from "./ITokenCache";

export interface ITokenCounterStats {
  cacheHits: number;
  cacheMisses: number;
  totalTokensCounted: number;
  totalFilesProcessed: number;
  totalProcessingTime: number;
  failedFiles: number;
  batchesProcessed: number;
  averageTokensPerFile: number;
  averageProcessingTime: number;
  lastProcessedFile?: string;
  lastError?: Error;
}

export interface ITokenCounterMetrics {
  tokensPerSecond: number;
  filesPerSecond: number;
  cacheHitRate: number;
  averageFileSize: number;
  peakMemoryUsage: number;
  currentTokenizerModel: TiktokenModel;
}

export interface ITokenizerModelConfig {
  name: TiktokenModel;
  contextLimit: number;
}

export interface ITokenCounterDeps {
  configManager: IConfigManager;
  fileSystem: IFileSystem;
  logger: ILogger;
  cache?: ITokenCache;
}

export interface ITokenCounterOptions {
  debug?: boolean;
  maxCacheAge?: number;
  enableCache?: boolean;
  batchSize?: number;
  modelOverride?: TiktokenModel;
}

export interface ITokenizeOptions {
  useCache?: boolean;
  modelOverride?: TiktokenModel;
}

export interface ITokenCounter extends IService {
  countTokens(filePath: string, text: string): Promise<number>;
  generateSummary(filesWithContent: IFileWithContent[]): Promise<ISummaryStats>;
  generateSummaryText(stats: ISummaryStats): string;
  printSummary(stats: ISummaryStats, outputFile: string): void;
  processBatch(
    files: IFileWithContent[],
    batchSize?: number,
  ): Promise<Array<{ file: string; tokens: number }>>;
  getStats(): ITokenCounterStats;
  getMetrics(): ITokenCounterMetrics;
  resetStats(): void;
}

================
File: src/core/tokenization/TokenCache.ts
================
// src/core/tokenization/TokenCache.ts

import crypto from "crypto";
import { ValidationError, CacheError } from "@/errors";
import {
  ITokenCache,
  ICacheEntry,
  ICacheStats,
  ITokenCacheDeps,
  ITokenCacheOptions,
} from "./interfaces/ITokenCache";
import { BaseService } from "@/types/services";

export type CacheOperation = "read" | "write" | "delete" | "clear" | "expire";

export class TokenCache extends BaseService implements ITokenCache {
  private readonly cachePath: string;
  private readonly projectRoot: string;
  private cache: Record<string, ICacheEntry> = {};
  private readonly maxCacheAge: number;
  private readonly debug: boolean;
  private stats: ICacheStats = {
    totalEntries: 0,
    oldestEntry: null,
    newestEntry: null,
    totalSize: 0,
    hitCount: 0,
    missCount: 0,
    invalidations: 0,
  };

  constructor(
    projectRoot: string,
    private readonly deps: ITokenCacheDeps,
    options: ITokenCacheOptions = {},
  ) {
    super();
    this.projectRoot = projectRoot;
    this.maxCacheAge = options.maxCacheAge || 7 * 24 * 60 * 60 * 1000; // 7 days default
    this.debug = options.debug || false;
    this.cachePath = this.deps.fileSystem.joinPath(
      projectRoot,
      ".gather-ts",
      "token-cache.json",
    );
  }

  public override async initialize(): Promise<void> {
    this.logDebug("Initializing TokenCache");

    try {
      await super.initialize();

      if (!this.deps.fileSystem.exists(this.projectRoot)) {
        throw new ValidationError("Project root does not exist", {
          projectRoot: this.projectRoot,
        });
      }

      await this.initializeCachePath();
      await this.loadCache();
    } catch (error) {
      throw new CacheError(
        `Failed to initialize TokenCache: ${error instanceof Error ? error.message : String(error)}`,
        "write",
      );
    }
  }

  private async initializeCachePath(): Promise<void> {
    try {
      const cacheDir = this.deps.fileSystem.getDirName(this.cachePath);
      if (!this.deps.fileSystem.exists(cacheDir)) {
        await this.deps.fileSystem.createDirectory(cacheDir, true);
        this.logDebug(`Created cache directory at ${cacheDir}`);
      }
    } catch (error) {
      throw new CacheError(
        `Failed to initialize cache path: ${error instanceof Error ? error.message : String(error)}`,
        "initialize",
      );
    }
  }

  public cleanup(): void {
    this.logDebug("Cleaning up TokenCache");
    this.saveCache();
    super.cleanup();
  }

  private logDebug(message: string): void {
    if (this.debug) {
      this.deps.logger.debug(message);
    }
  }

  private handleError(operation: string, error: unknown, key?: string): never {
    const message = error instanceof Error ? error.message : String(error);
    const cacheError = new CacheError(
      `Cache ${operation} failed: ${message}`,
      operation as "read" | "write" | "delete" | "clear",
      key,
    );
    this.deps.logger.error(cacheError.message);
    throw cacheError;
  }

  private validateCacheEntry(entry: unknown): entry is ICacheEntry {
    if (!entry || typeof entry !== "object") {
      return false;
    }

    const candidate = entry as ICacheEntry;
    return (
      typeof candidate.hash === "string" &&
      typeof candidate.tokens === "number" &&
      typeof candidate.lastUpdated === "string" &&
      !isNaN(Date.parse(candidate.lastUpdated))
    );
  }

  private getRelativeCachePath(absolutePath: string): string {
    return this.deps.fileSystem.getRelativePath(this.projectRoot, absolutePath);
  }

  private async loadCache(): Promise<void> {
    try {
      if (this.deps.fileSystem.exists(this.cachePath)) {
        const content = await this.deps.fileSystem.readFile(this.cachePath);
        const parsed = JSON.parse(content);

        if (typeof parsed !== "object" || parsed === null) {
          throw new ValidationError("Invalid cache file structure");
        }

        const validatedCache: Record<string, ICacheEntry> = {};
        const now = Date.now();
        let expiredCount = 0;
        let invalidCount = 0;

        Object.entries(parsed).forEach(([key, entry]) => {
          if (!this.validateCacheEntry(entry)) {
            invalidCount++;
            this.logDebug(`Invalid cache entry for ${key}, skipping`);
            return;
          }

          const entryAge = now - Date.parse(entry.lastUpdated);
          if (entryAge > this.maxCacheAge) {
            expiredCount++;
            this.stats.invalidations++;
            this.logDebug(`Skipping expired cache entry for ${key}`);
            return;
          }

          validatedCache[key] = entry;
        });

        this.cache = validatedCache;
        this.updateStats();
        this.logDebug(
          `Loaded ${Object.keys(this.cache).length} valid cache entries ` +
            `(${expiredCount} expired, ${invalidCount} invalid)`,
        );
      }
    } catch (error) {
      this.handleError("read", error);
    }
  }

  private async saveCache(): Promise<void> {
    try {
      await this.deps.fileSystem.writeFile(
        this.cachePath,
        JSON.stringify(this.cache, null, 2),
      );
      this.logDebug(`Saved ${Object.keys(this.cache).length} cache entries`);
    } catch (error) {
      this.handleError("write", error);
    }
  }

  private computeHash(content: string): string {
    try {
      return crypto.createHash("md5").update(content).digest("hex");
    } catch (error) {
      this.handleError("hash", error);
    }
  }

  public getCachedTokenCount(filePath: string, content: string): number | null {
    if (!filePath || typeof filePath !== "string") {
      throw new ValidationError("Invalid file path provided", { filePath });
    }

    try {
      const relativePath = this.getRelativeCachePath(filePath);
      const hash = this.computeHash(content);
      const cached = this.cache[relativePath];

      if (cached && cached.hash === hash) {
        const entryAge = Date.now() - Date.parse(cached.lastUpdated);
        if (entryAge > this.maxCacheAge) {
          this.logDebug(`Cache entry for ${relativePath} has expired`);
          delete this.cache[relativePath];
          this.stats.invalidations++;
          this.stats.missCount++;
          return null;
        }
        this.stats.hitCount++;
        return cached.tokens;
      }
      this.stats.missCount++;
      return null;
    } catch (error) {
      this.handleError("read", error, filePath);
    }
  }

  public cacheTokenCount(
    filePath: string,
    content: string,
    tokens: number,
  ): void {
    if (!filePath || typeof filePath !== "string") {
      throw new ValidationError("Invalid file path provided", { filePath });
    }

    if (typeof tokens !== "number" || isNaN(tokens) || tokens < 0) {
      throw new ValidationError("Invalid token count provided", {
        filePath,
        tokens,
      });
    }

    try {
      const relativePath = this.getRelativeCachePath(filePath);
      const entry: ICacheEntry = {
        hash: this.computeHash(content),
        tokens,
        lastUpdated: new Date().toISOString(),
      };

      this.cache[relativePath] = entry;
      this.updateStats();
      this.saveCache();
      this.logDebug(`Cached ${tokens} tokens for ${relativePath}`);
    } catch (error) {
      this.handleError("write", error, filePath);
    }
  }

  public clear(): void {
    try {
      this.cache = {};
      this.updateStats();
      if (this.deps.fileSystem.exists(this.cachePath)) {
        this.deps.fileSystem.deleteFile(this.cachePath);
        this.logDebug("Cleared cache file");
      }
    } catch (error) {
      this.handleError("clear", error);
    }
  }

  private updateStats(): void {
    const entries = Object.values(this.cache);
    let oldestDate = Date.now();
    let newestDate = 0;

    entries.forEach(entry => {
      const timestamp = Date.parse(entry.lastUpdated);
      oldestDate = Math.min(oldestDate, timestamp);
      newestDate = Math.max(newestDate, timestamp);
    });

    this.stats.totalEntries = entries.length;
    this.stats.oldestEntry =
      entries.length > 0 ? new Date(oldestDate).toISOString() : null;
    this.stats.newestEntry =
      entries.length > 0 ? new Date(newestDate).toISOString() : null;
    this.stats.totalSize = Buffer.byteLength(JSON.stringify(this.cache));
  }

  public getCacheStats(): ICacheStats {
    return { ...this.stats };
  }
}

================
File: src/core/tokenization/TokenCounter.ts
================
// src/core/tokenization/TokenCounter.ts

import { encoding_for_model } from "@dqbd/tiktoken";
import { TokenizationError, ValidationError } from "@/errors";
import {
  ITokenCounter,
  ITokenCounterDeps,
  ITokenCounterOptions,
  ITokenCounterStats,
  ITokenCounterMetrics,
  ITokenizeOptions,
  ITokenizerModelConfig,
} from "./interfaces/ITokenCounter";
import { TiktokenModel } from "models/tokenizer";
import { IFileWithContent } from "files";
import { ISummaryStats } from "stats";
import { BaseService } from "@/types/services";

const MODEL_CONFIGS: Record<TiktokenModel, ITokenizerModelConfig> = {
  "gpt-3.5-turbo": { name: "gpt-3.5-turbo", contextLimit: 16384 },
  "gpt-4": { name: "gpt-4", contextLimit: 8192 },
  "gpt-4o": { name: "gpt-4o", contextLimit: 128000 },
  "gpt-4o-mini": { name: "gpt-4o-mini", contextLimit: 128000 },
  o1: { name: "o1", contextLimit: 128000 },
  "o1-mini": { name: "o1-mini", contextLimit: 128000 },
  "o3-mini": { name: "o3-mini", contextLimit: 200000 },
};

export class TokenCounter extends BaseService implements ITokenCounter {
  private encoder: any = null;
  private readonly debug: boolean;
  private readonly batchSize: number;
  private readonly modelOverride?: TiktokenModel;
  private readonly enableCache: boolean;
  private startTime: number;
  private stats: ITokenCounterStats = {
    cacheHits: 0,
    cacheMisses: 0,
    totalTokensCounted: 0,
    totalFilesProcessed: 0,
    totalProcessingTime: 0,
    failedFiles: 0,
    batchesProcessed: 0,
    averageTokensPerFile: 0,
    averageProcessingTime: 0,
  };

  constructor(
    private readonly deps: ITokenCounterDeps,
    options: ITokenCounterOptions = {},
  ) {
    super();
    this.debug = options.debug || false;
    this.batchSize = options.batchSize || 100;
    this.modelOverride = options.modelOverride;
    this.enableCache = options.enableCache ?? true;
    this.startTime = Date.now();
  }

  public override async initialize(): Promise<void> {
    await super.initialize();
    this.logDebug("Initializing TokenCounter");

    try {
      // Initialize encoder
      await this.getEncoder();

      // Initialize cache if provided
      if (this.deps.cache?.initialize) {
        await this.deps.cache.initialize();
      }

      this.startTime = Date.now();
      this.logDebug("TokenCounter initialization complete");
    } catch (error) {
      this.handleError(error, "initialize");
    }
  }

  public override cleanup(): void {
    this.logDebug("Cleaning up TokenCounter");
    try {
      if (this.encoder) {
        this.encoder.free();
        this.encoder = null;
      }
      if (this.deps.cache?.cleanup) {
        this.deps.cache.cleanup();
      }
      super.cleanup();
    } catch (error) {
      this.deps.logger.warn(
        `Cleanup error: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  private initializeStats(): void {
    this.stats = {
      cacheHits: 0,
      cacheMisses: 0,
      totalTokensCounted: 0,
      totalFilesProcessed: 0,
      totalProcessingTime: 0,
      failedFiles: 0,
      batchesProcessed: 0,
      averageTokensPerFile: 0,
      averageProcessingTime: 0,
    };
  }

  private logDebug(message: string): void {
    if (this.debug) {
      this.deps.logger.debug(message);
    }
  }

  private handleError(
    error: unknown,
    operation: string,
    filePath?: string,
  ): never {
    const message = error instanceof Error ? error.message : String(error);
    const tokenizationError = new TokenizationError(
      `Tokenization ${operation} failed: ${message}`,
      filePath || "unknown",
      operation as "encode" | "decode" | "initialize" | "cleanup",
      this.getCurrentModel(),
    );
    this.deps.logger.error(tokenizationError.message);
    throw tokenizationError;
  }

  private getCurrentModel(): TiktokenModel {
    return (
      this.modelOverride ||
      (this.deps.configManager.getTokenizerModel() as TiktokenModel)
    );
  }

  private async getEncoder() {
    if (!this.encoder) {
      const modelName = this.getCurrentModel();
      const modelConfig = MODEL_CONFIGS[modelName];

      if (!modelConfig) {
        throw new ValidationError("Unsupported tokenizer model", {
          model: modelName,
          supportedModels: Object.keys(MODEL_CONFIGS),
        });
      }

      try {
        this.encoder = await encoding_for_model(modelConfig.name);
        this.logDebug(`Initialized encoder for model: ${modelConfig.name}`);
      } catch (error) {
        this.handleError(error, "initialize");
      }
    }
    return this.encoder;
  }

  public async countTokens(
    filePath: string,
    text: string,
    options: ITokenizeOptions = {},
  ): Promise<number> {
    const startTime = Date.now();

    if (!this.isInitialized) {
      throw new TokenizationError(
        "TokenCounter not initialized",
        filePath,
        "encode",
        this.getCurrentModel(),
      );
    }

    // Handle empty text more gracefully
    if (!text || text.trim() === "") {
      this.logDebug(`Empty content in file: ${filePath}, returning 0 tokens`);
      this.updateStats({
        totalTokensCounted: 0,
        totalFilesProcessed: 1,
        totalProcessingTime: Date.now() - startTime,
        lastProcessedFile: filePath,
      });
      return 0;
    }

    try {
      this.logDebug(`Counting tokens for ${filePath}`);

      // Check cache first if enabled and not explicitly disabled for this operation
      if (this.enableCache && options.useCache !== false && this.deps.cache) {
        const cachedCount = this.deps.cache.getCachedTokenCount(filePath, text);
        if (cachedCount !== null) {
          this.updateStats({
            cacheHits: 1,
            totalTokensCounted: cachedCount,
            totalFilesProcessed: 1,
            totalProcessingTime: Date.now() - startTime,
          });
          this.logDebug(`Cache hit for ${filePath}: ${cachedCount} tokens`);
          return cachedCount;
        }
        this.stats.cacheMisses++;
        this.logDebug(`Cache miss for ${filePath}`);
      }

      const encoder = await this.getEncoder();
      const tokenCount = encoder.encode(text).length;

      // Cache the result if enabled and not explicitly disabled for this operation
      if (this.enableCache && options.useCache !== false && this.deps.cache) {
        try {
          this.deps.cache.cacheTokenCount(filePath, text, tokenCount);
          this.logDebug(`Cached ${tokenCount} tokens for ${filePath}`);
        } catch (error) {
          this.deps.logger.warn(
            `Failed to cache token count for ${filePath}: ${error instanceof Error ? error.message : String(error)}`,
          );
        }
      }

      this.updateStats({
        totalTokensCounted: tokenCount,
        totalFilesProcessed: 1,
        totalProcessingTime: Date.now() - startTime,
        lastProcessedFile: filePath,
      });

      this.logDebug(`Counted ${tokenCount} tokens for ${filePath}`);
      return tokenCount;
    } catch (error) {
      this.stats.failedFiles++;
      this.stats.lastError =
        error instanceof Error ? error : new Error(String(error));
      this.handleError(error, "encode", filePath);
    }
  }

  private updateStats(update: Partial<ITokenCounterStats>): void {
    Object.assign(this.stats, update);

    if (this.stats.totalFilesProcessed > 0) {
      this.stats.averageTokensPerFile =
        this.stats.totalTokensCounted / this.stats.totalFilesProcessed;
      this.stats.averageProcessingTime =
        this.stats.totalProcessingTime / this.stats.totalFilesProcessed;
    }
  }

  public async generateSummary(
    files: IFileWithContent[],
  ): Promise<ISummaryStats> {
    this.logDebug(`Generating summary for ${files.length} files`);

    if (!files.length) {
      throw new ValidationError("No files provided for summary generation");
    }

    const results = await this.processBatch(files);
    const fileStats = results.map(result => ({
      path: result.file,
      chars: files.find(f => f.path === result.file)?.content.length || 0,
      tokens: result.tokens,
    }));

    const topFilesCount = this.deps.configManager.getTopFilesCount();
    const topFiles = [...fileStats]
      .sort((a, b) => b.tokens - a.tokens)
      .slice(0, topFilesCount);

    const totalStats = fileStats.reduce(
      (acc, file) => ({
        chars: acc.chars + file.chars,
        tokens: acc.tokens + file.tokens,
      }),
      { chars: 0, tokens: 0 },
    );

    const tokenValues = fileStats.map(stat => stat.tokens);
    const averageTokens = totalStats.tokens / fileStats.length;
    const maxTokens = Math.max(...tokenValues);
    const minTokens = Math.min(...tokenValues);

    this.logDebug(`Summary generated: ${totalStats.tokens} total tokens`);

    return {
      totalFiles: fileStats.length,
      totalChars: totalStats.chars,
      totalTokens: totalStats.tokens,
      topFiles,
      generationTime: new Date().toISOString(),
      averageTokensPerFile: averageTokens,
      maxTokensInFile: maxTokens,
      minTokensInFile: minTokens,
    };
  }

  public async processBatch(
    files: IFileWithContent[],
    batchSize: number = this.batchSize,
  ): Promise<Array<{ file: string; tokens: number }>> {
    this.logDebug(`Processing batch of ${files.length} files`);

    const results: Array<{ file: string; tokens: number }> = [];

    for (let i = 0; i < files.length; i += batchSize) {
      const batch = files.slice(i, i + batchSize);
      const batchResults = await Promise.all(
        batch.map(async file => ({
          file: file.path,
          tokens: await this.countTokens(file.path, file.content),
        })),
      );
      results.push(...batchResults);
      this.stats.batchesProcessed++;

      const progress = Math.floor(((i + batch.length) / files.length) * 100);
      this.logDebug(
        `Processed batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(files.length / batchSize)} (${progress}%)`,
      );
    }

    return results;
  }

  public getStats(): ITokenCounterStats {
    return { ...this.stats };
  }

  public getMetrics(): ITokenCounterMetrics {
    const uptime = Date.now() - this.startTime;
    const totalHits = this.stats.cacheHits + this.stats.cacheMisses;

    return {
      tokensPerSecond: this.stats.totalTokensCounted / (uptime / 1000),
      filesPerSecond: this.stats.totalFilesProcessed / (uptime / 1000),
      cacheHitRate: totalHits > 0 ? this.stats.cacheHits / totalHits : 0,
      averageFileSize:
        this.stats.totalTokensCounted / this.stats.totalFilesProcessed,
      peakMemoryUsage: process.memoryUsage().heapUsed,
      currentTokenizerModel: this.getCurrentModel(),
    };
  }

  public resetStats(): void {
    this.logDebug("Resetting stats");
    this.initializeStats();
    this.startTime = Date.now();
  }

  public generateSummaryText(stats: ISummaryStats): string {
    this.logDebug("Generating summary text");

    const config = this.deps.configManager.getConfig();
    const summary: string[] = [];

    if (config.outputFormat.includeSummaryInFile) {
      summary.push(
        "================================================================",
        "Token Analysis Summary",
        "================================================================\n",
      );

      if (config.outputFormat.includeGenerationTime) {
        summary.push(`Generated on: ${stats.generationTime}\n`);
      }

      summary.push("Top Files by Token Usage:", "------------------------");

      stats.topFiles.forEach((file, index) => {
        summary.push(
          `${index + 1}. ${file.path}`,
          `   ${file.chars.toLocaleString()} characters, ${file.tokens.toLocaleString()} tokens`,
        );
      });

      summary.push(
        "\nOverall Statistics:",
        "------------------",
        `Total Files: ${stats.totalFiles}`,
        `Total Characters: ${stats.totalChars.toLocaleString()}`,
        `Total Tokens: ${stats.totalTokens.toLocaleString()}`,
        `Average Tokens Per File: ${stats.averageTokensPerFile?.toFixed(2) ?? "N/A"}`,
        `Maximum Tokens in a File: ${stats.maxTokensInFile?.toLocaleString() ?? "N/A"}`,
        `Minimum Tokens in a File: ${stats.minTokensInFile?.toLocaleString() ?? "N/A"}`,
      );

      const metrics = this.getMetrics();
      summary.push(
        "\nPerformance Metrics:",
        "-------------------",
        `Processing Speed: ${metrics.tokensPerSecond.toFixed(2)} tokens/sec`,
        `Cache Hit Rate: ${(metrics.cacheHitRate * 100).toFixed(1)}%`,
        `Peak Memory Usage: ${(metrics.peakMemoryUsage / 1024 / 1024).toFixed(2)} MB`,
      );
    }

    return summary.join("\n");
  }

  public printSummary(stats: ISummaryStats, outputFile: string): void {
    this.logDebug("Printing summary");

    if (!stats || typeof stats !== "object") {
      throw new ValidationError("Invalid stats object provided");
    }

    this.deps.logger.success("\nToken analysis completed!");

    this.deps.logger.info(
      `\nTop ${stats.topFiles.length} Files by Token Usage:`,
    );
    this.deps.logger.info(
      "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",
    );

    stats.topFiles.forEach((file, index) => {
      const formattedPath = file.path.padEnd(45);
      this.deps.logger.info(
        `${(index + 1).toString().padStart(2)}. ${formattedPath}` +
          `(${file.chars.toString().padStart(6)} chars, ${file.tokens.toString().padStart(6)} tokens)`,
      );
    });

    const metrics = this.getMetrics();

    this.deps.logger.info("\nüìä Analysis Summary:");
    this.deps.logger.info("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    this.deps.logger.info(`Total Files: ${stats.totalFiles}`);
    this.deps.logger.info(`Total Chars: ${stats.totalChars.toLocaleString()}`);
    this.deps.logger.info(
      `Total Tokens: ${stats.totalTokens.toLocaleString()}`,
    );
    this.deps.logger.info(
      `Avg Tokens/File: ${stats.averageTokensPerFile?.toFixed(2) ?? "N/A"}`,
    );
    this.deps.logger.info(
      `Processing Speed: ${metrics.tokensPerSecond.toFixed(2)} tokens/sec`,
    );
    this.deps.logger.info(
      `Cache Hit Rate: ${(metrics.cacheHitRate * 100).toFixed(1)}%`,
    );
    this.deps.logger.info(`Output File: ${outputFile}`);

    // Check token limit warning
    const warning = this.deps.configManager.getTokenWarning(stats.totalTokens);
    if (warning) {
      this.deps.logger.warn(`\n${warning}`);
    }
  }
}

================
File: src/errors/exceptions/index.ts
================
import {
  IBaseError,
  IErrorDetails,
  IValidationErrorDetails,
  IFileSystemErrorDetails,
  ITokenizationErrorDetails,
  IDependencyAnalysisErrorDetails,
} from "errors";
import {
  ICacheErrorDetails,
  ICompilationErrorDetails,
} from "../interfaces/error-types";

/**
 * Base class for all gather-ts errors
 */
export abstract class GatherTSError extends Error implements IBaseError {
  public abstract readonly name: string;
  public readonly details?: IErrorDetails;
  public readonly timestamp: string;

  constructor(message: string, details?: IErrorDetails) {
    super(message);
    this.details = details;
    this.timestamp = new Date().toISOString();

    // Ensure proper prototype chain for instanceof checks
    Object.setPrototypeOf(this, new.target.prototype);
  }

  public toJSON() {
    return {
      name: this.name,
      message: this.message,
      details: this.details,
      timestamp: this.timestamp,
      stack: this.stack,
    };
  }
}

/**
 * Input validation errors
 */
export class ValidationError extends GatherTSError {
  public readonly name = "ValidationError";

  constructor(message: string, details?: IValidationErrorDetails) {
    super(message, details);
  }
}

/**
 * File system operation errors
 */
export class FileSystemError extends GatherTSError {
  public readonly name = "FileSystemError";

  constructor(
    message: string,
    filePath: string,
    operation: IFileSystemErrorDetails["operation"],
  ) {
    super(message, { filePath, operation });
  }

  get filePath(): string {
    return (this.details as IFileSystemErrorDetails).filePath;
  }

  get operation(): IFileSystemErrorDetails["operation"] {
    return (this.details as IFileSystemErrorDetails).operation;
  }
}

/**
 * Configuration related errors
 */
export class ConfigurationError extends GatherTSError {
  public readonly name = "ConfigurationError";

  constructor(message: string, configPath: string) {
    // Ensure configPath is non-null and non-undefined
    if (!configPath) {
      configPath = "unknown";
    }
    super(message, { configPath });
  }
}

/**
 * Token processing errors
 */
export class TokenizationError extends GatherTSError {
  public readonly name = "TokenizationError";

  constructor(
    message: string,
    filePath: string,
    operation: ITokenizationErrorDetails["operation"],
    model?: string,
  ) {
    super(message, { filePath, operation, model });
  }

  get filePath(): string {
    return (this.details as ITokenizationErrorDetails).filePath;
  }

  get operation(): ITokenizationErrorDetails["operation"] {
    return (this.details as ITokenizationErrorDetails).operation;
  }
}

/**
 * Dependency analysis errors
 */
export class DependencyAnalysisError extends GatherTSError {
  public readonly name = "DependencyAnalysisError";

  constructor(
    message: string,
    entryPoint?: string,
    failedDependencies?: string[],
  ) {
    super(message, { entryPoint, failedDependencies });
  }

  get entryPoint(): string | undefined {
    return (this.details as IDependencyAnalysisErrorDetails).entryPoint;
  }

  get failedDependencies(): string[] | undefined {
    return (this.details as IDependencyAnalysisErrorDetails).failedDependencies;
  }
}

/**
 * Cache operation errors
 */
export class CacheError extends GatherTSError {
  public readonly name = "CacheError";

  constructor(
    message: string,
    operation: ICacheErrorDetails["operation"],
    key?: string,
  ) {
    super(message, { operation, key });
  }

  get operation(): ICacheErrorDetails["operation"] {
    return (this.details as ICacheErrorDetails).operation;
  }
}

/**
 * Compilation process errors
 */
export class CompilationError extends GatherTSError {
  public readonly name = "CompilationError";

  constructor(
    message: string,
    phase: ICompilationErrorDetails["phase"],
    details?: Omit<ICompilationErrorDetails, "phase">,
  ) {
    super(message, { phase, ...details });
  }

  get phase(): ICompilationErrorDetails["phase"] {
    return (this.details as ICompilationErrorDetails).phase;
  }
}

/**
 * Timeout errors
 */
export class TimeoutError extends GatherTSError {
  public readonly name = "TimeoutError";

  constructor(message: string, operation: string, timeout: number) {
    super(message, { operation, timeout });
  }
}

/**
 * Resource usage limit errors
 */
export class ResourceLimitError extends GatherTSError {
  public readonly name = "ResourceLimitError";

  constructor(
    message: string,
    resource: string,
    limit: number,
    actual: number,
  ) {
    super(message, { resource, limit, actual });
  }
}

================
File: src/errors/handlers/ErrorHandler.ts
================
// src/errors/handlers/ErrorHandler.ts

import { BaseService } from "@/types/services";
import { GatherTSError } from "../exceptions";
import {
  IErrorHandler,
  IErrorProcessingStrategy,
  IErrorHandlerDeps,
  IErrorHandlerOptions,
  IErrorOperationOptions,
} from "../interfaces/IErrorHandler";

export class ErrorHandler extends BaseService implements IErrorHandler {
  private readonly processingStrategies: IErrorProcessingStrategy[] = [];
  private readonly debug: boolean;
  private readonly logToConsole: boolean;
  private readonly logToFile: boolean;
  private readonly logFilePath?: string;
  private readonly rethrow: boolean;

  constructor(
    private readonly deps: IErrorHandlerDeps,
    options: IErrorHandlerOptions = {},
  ) {
    super();
    this.debug = options.debug || false;
    this.logToConsole = options.logToConsole ?? true;
    this.logToFile = options.logToFile || false;
    this.logFilePath = options.logFilePath;
    this.rethrow = options.rethrow || false;

    if (this.logToConsole) {
      this.registerStrategy(this.createConsoleStrategy());
    }
  }

  public override async initialize(): Promise<void> {
    await super.initialize();
    this.logDebug("Initializing ErrorHandler");

    try {
      if (this.logToFile && this.logFilePath) {
        this.logDebug(`Setting up file logging at ${this.logFilePath}`);
        const logDir = this.deps.fileSystem.getDirName(this.logFilePath);

        if (!this.deps.fileSystem.exists(logDir)) {
          await this.deps.fileSystem.createDirectory(logDir, true);
        }

        this.registerStrategy(this.createFileStrategy());
      }

      this.logDebug("ErrorHandler initialization complete");
    } catch (error) {
      this.deps.logger.error(
        `Failed to initialize ErrorHandler: ${error instanceof Error ? error.message : String(error)}`,
      );
      throw error;
    }
  }

  public override cleanup(): void {
    this.logDebug("Cleaning up ErrorHandler");
    this.processingStrategies.length = 0;
    super.cleanup();
  }

  private logDebug(message: string): void {
    if (this.debug) {
      this.deps.logger.debug(message);
    }
  }

  public registerStrategy(strategy: IErrorProcessingStrategy): void {
    this.logDebug("Registering new error processing strategy");
    this.processingStrategies.push(strategy);
  }

  public handle(error: Error, options: IErrorOperationOptions = {}): void {
    this.logDebug(`Handling error: ${error.message}`);

    const normalizedError = this.deps.errorUtils.normalizeError(error);
    const context = this.deps.errorUtils.extractErrorContext(normalizedError);

    let processedByStrategy = false;
    for (const strategy of this.processingStrategies) {
      if (strategy.shouldHandle(normalizedError)) {
        processedByStrategy = true;
        this.logDebug("Processing error through strategy");
        strategy.handle(normalizedError, context);
      }
    }

    if (!processedByStrategy) {
      this.logDebug(
        "No strategy handled the error, using default console logging",
      );
      this.deps.logger.error(normalizedError.message);
    }

    if (options.rethrow || this.rethrow) {
      this.logDebug("Rethrowing error as configured");
      throw normalizedError;
    }
  }

  public handleBatch(errors: Error[]): void {
    this.logDebug(`Processing batch of ${errors.length} errors`);

    if (errors.length === 0) {
      return;
    }

    const aggregatedError = this.deps.errorUtils.aggregateErrors(errors);
    this.handle(aggregatedError);
  }

  public async createErrorBoundary(fn: () => Promise<void>): Promise<void> {
    try {
      await fn();
    } catch (error) {
      this.logDebug("Error caught in error boundary");
      this.handle(error instanceof Error ? error : new Error(String(error)));
      return Promise.reject(error);
    }
  }

  private createConsoleStrategy(): IErrorProcessingStrategy {
    return {
      shouldHandle: () => true,
      handle: (error: Error, context: Record<string, unknown>) => {
        const classification = this.deps.errorUtils.classifyError(error);

        switch (classification.severity) {
          case "error":
            this.deps.logger.error(classification.message);
            if (classification.details) {
              if (this.debug) {
                this.deps.logger.debug(
                  `Error details: ${JSON.stringify(classification.details)}`,
                );
              }
            }
            break;
          case "warning":
            this.deps.logger.warn(classification.message);
            break;
          case "info":
            this.deps.logger.info(classification.message);
            break;
        }

        if (this.debug && classification.stackTrace) {
          this.logDebug("Stack trace:" + classification.stackTrace);
        }
      },
    };
  }

  private createFileStrategy(): IErrorProcessingStrategy {
    if (!this.logFilePath) {
      throw new Error("Log file path not configured");
    }

    return {
      shouldHandle: (error: Error) => error instanceof GatherTSError,
      handle: (error: Error, context: Record<string, unknown>) => {
        const timestamp = new Date().toISOString();
        const classification = this.deps.errorUtils.classifyError(error);

        const logEntry = {
          timestamp,
          level: classification.severity,
          type: classification.type,
          message: classification.message,
          details: classification.details,
          context,
        };

        try {
          this.deps.fileSystem.writeFileSync(
            this.logFilePath!,
            JSON.stringify(logEntry) + "\n",
            { flag: "a" },
          );
        } catch (writeError) {
          this.deps.logger.error(
            `Failed to write to error log: ${writeError instanceof Error ? writeError.message : String(writeError)}`,
          );
        }
      },
    };
  }
}

================
File: src/errors/index.ts
================
// src/errors/index.ts

export * from "./exceptions";
export * from "./handlers/ErrorHandler";
export * from "./utils/ErrorUtils";
export * from "./interfaces/IError";

import { ErrorHandler } from "./handlers/ErrorHandler";
import {
  IErrorHandlerDeps,
  IErrorHandlerOptions,
  IErrorHandler,
} from "./interfaces/IErrorHandler";

export function createErrorHandler(
  deps: IErrorHandlerDeps,
  options?: IErrorHandlerOptions,
): IErrorHandler {
  return new ErrorHandler(deps, options);
}

================
File: src/errors/interfaces/error-types.ts
================
import { IErrorDetails } from "errors";

export interface IValidationErrorDetails extends IErrorDetails {
  filePath?: string;
  providedValue?: unknown;
  expectedType?: string;
  allowedValues?: unknown[];
}

export interface IFileSystemErrorDetails extends IErrorDetails {
  filePath: string;
  operation: "read" | "write" | "delete" | "create" | "move" | "copy";
}

export interface IConfigurationErrorDetails extends IErrorDetails {
  configPath: string;
  invalidFields?: string[];
  providedValue?: unknown;
  allowedValues?: unknown[];
}

export interface ITokenizationErrorDetails extends IErrorDetails {
  filePath: string;
  operation: "encode" | "decode" | "initialize" | "cleanup";
  model?: string;
}

export interface IDependencyAnalysisErrorDetails extends IErrorDetails {
  entryPoint?: string;
  failedDependencies?: string[];
}

export interface ICacheErrorDetails extends IErrorDetails {
  operation: "read" | "write" | "delete" | "clear" | "expire" | "initialize";
  key?: string;
}

export interface ICompilationErrorDetails extends IErrorDetails {
  phase:
    | "initialization"
    | "dependency-analysis"
    | "file-processing"
    | "tokenization"
    | "output-generation";
  filePath?: string;
  sourceCode?: string;
  lineNumber?: number;
  columnNumber?: number;
}

================
File: src/errors/interfaces/IError.ts
================
// src/errors/interfaces/IError.ts

import { IErrorDetails } from "@/types/errors";


export interface IErrorClassification {
  type: string;
  severity: "error" | "warning" | "info";
  message: string;
  details?: IErrorDetails;
  stackTrace?: string;
}

export interface IErrorTransformation {
  condition: (error: Error) => boolean;
  transform: (error: Error) => Error;
}

export interface IErrorMetrics {
  totalErrors: number;
  errorsByType: Record<string, number>;
  totalWarnings: number;
  startTime: number;
  lastErrorTime?: number;
}

================
File: src/errors/interfaces/IErrorHandler.ts
================
// src/errors/interfaces/IErrorHandler.ts

import { IService } from "@/types/services";
import { ILogger } from "@/utils/logging/interfaces/ILogger";
import { IFileSystem } from "@/utils/filesystem/interfaces/IFileSystem";
import { IErrorUtils } from "./IErrorUtils";

// Error Handler types
export interface IErrorProcessingStrategy {
  shouldHandle: (error: Error) => boolean;
  handle: (error: Error, context: Record<string, unknown>) => void;
}

export interface IErrorOperationOptions {
  rethrow?: boolean;
  context?: Record<string, unknown>;
}

export interface IErrorHandlerDeps {
  logger: ILogger;
  fileSystem: IFileSystem;
  errorUtils: IErrorUtils;
}

export interface IErrorHandlerOptions {
  debug?: boolean;
  logToConsole?: boolean;
  logToFile?: boolean;
  logFilePath?: string;
  rethrow?: boolean;
}

export interface IErrorHandler extends IService {
  handle(error: Error, options?: IErrorOperationOptions): void;
  handleBatch(errors: Error[]): void;
  createErrorBoundary(fn: () => Promise<void>): Promise<void>;
  registerStrategy(strategy: IErrorProcessingStrategy): void;
}

export interface IErrorHandlerConfig extends IErrorHandlerOptions {
  strategies?: IErrorProcessingStrategy[];
}

================
File: src/errors/interfaces/IErrorUtils.ts
================
import { ILogger } from "@/utils";
import { IBaseError, IErrorDetails } from "errors";
import { IService } from "@/types/services";
import { IErrorClassification, IErrorTransformation } from "./IError";

// Error Utils types
export interface IErrorUtilsDeps {
  logger: ILogger;
}

export interface IErrorUtilsOptions {
  debug?: boolean;
}

export interface IErrorUtils extends IService {
  isGatherTSError(error: unknown): error is IBaseError;
  wrapError(error: unknown, context: string): Error;
  formatErrorDetails(details: IErrorDetails): string;
  aggregateErrors(errors: Error[]): Error;
  classifyError(error: unknown): IErrorClassification;
  transformError(
    error: unknown,
    transformations: IErrorTransformation[],
  ): Error;
  extractErrorContext(error: Error): Record<string, unknown>;
  normalizeError(error: unknown): Error;
}

================
File: src/errors/utils/ErrorUtils.ts
================
// src/errors/utils/ErrorUtils.ts

import {
  IErrorClassification,
  IErrorTransformation,
} from "../interfaces/IError";
import { GatherTSError } from "../exceptions";
import {
  IErrorUtils,
  IErrorUtilsDeps,
  IErrorUtilsOptions,
} from "../interfaces/IErrorUtils";
import { BaseService } from "@/types/services";
import { IBaseError, IErrorDetails } from "@/types/errors";

export class ErrorUtils extends BaseService implements IErrorUtils {
  private readonly debug: boolean;

  constructor(
    private readonly deps: IErrorUtilsDeps,
    options: IErrorUtilsOptions = {},
  ) {
    super();
    this.debug = options.debug || false;
  }

  public override async initialize(): Promise<void> {
    await super.initialize();
    this.logDebug("ErrorUtils service initialized");
  }

  public override cleanup(): void {
    this.logDebug("ErrorUtils service cleanup");
    super.cleanup();
  }

  private logDebug(message: string): void {
    if (this.debug) {
      this.deps.logger.debug(message);
    }
  }

  public isGatherTSError(error: unknown): error is IBaseError {
    this.checkInitialized();
    return error instanceof GatherTSError;
  }

  public wrapError(error: unknown, context: string): Error {
    if (error instanceof GatherTSError) {
      return error;
    }

    const message = error instanceof Error ? error.message : String(error);
    const wrapped = new Error(`${context}: ${message}`);

    if (error instanceof Error) {
      wrapped.stack = error.stack;
    }

    return wrapped;
  }

  public formatErrorDetails(details: IErrorDetails): string {
    return Object.entries(details)
      .filter(([_, value]) => value !== undefined)
      .map(([key, value]) => {
        if (Array.isArray(value)) {
          return `${key}: [${value.join(", ")}]`;
        }
        if (value instanceof Error) {
          return `${key}: ${value.message}`;
        }
        if (typeof value === "object" && value !== null) {
          return `${key}: ${JSON.stringify(value)}`;
        }
        return `${key}: ${value}`;
      })
      .join(", ");
  }

  public aggregateErrors(errors: Error[]): Error {
    if (errors.length === 0) {
      return new Error("No errors to aggregate");
    }

    if (errors.length === 1) {
      return errors[0];
    }

    const messages = errors.map((err, index) => {
      const prefix = errors.length > 1 ? `${index + 1}. ` : "";
      return prefix + (err instanceof Error ? err.message : String(err));
    });

    const err = new Error(`Multiple errors occurred:\n${messages.join("\n")}`);
    err.name = "AggregateError";
    return err;
  }

  public classifyError(error: unknown): IErrorClassification {
    const baseClassification: IErrorClassification = {
      type: "UnknownError",
      severity: "error",
      message: "",
      details: undefined,
      stackTrace: undefined,
    };

    if (error instanceof GatherTSError) {
      return {
        ...baseClassification,
        type: error.name,
        message: error.message,
        details: error.details,
        stackTrace: error.stack,
      };
    }

    if (error instanceof Error) {
      return {
        ...baseClassification,
        type: error.name,
        message: error.message,
        stackTrace: error.stack,
      };
    }

    return {
      ...baseClassification,
      message: String(error),
    };
  }

  public transformError(
    error: unknown,
    transformations: IErrorTransformation[],
  ): Error {
    let transformed = error instanceof Error ? error : new Error(String(error));

    for (const transformation of transformations) {
      if (transformation.condition(transformed)) {
        transformed = transformation.transform(transformed);
      }
    }

    return transformed;
  }

  public extractErrorContext(error: Error): Record<string, unknown> {
    const context: Record<string, unknown> = {
      name: error.name,
      message: error.message,
    };

    if (error instanceof GatherTSError && error.details) {
      context.details = error.details;
    }

    if (this.debug && error.stack) {
      context.stack = error.stack;
    }

    return context;
  }

  public normalizeError(error: unknown): Error {
    if (error instanceof Error) {
      return error;
    }

    if (error instanceof Object) {
      return new Error(JSON.stringify(error));
    }

    return new Error(String(error));
  }
}

================
File: src/index.ts
================
// src/index.ts
export * from './cli';
export * from './config';
export * from './core/compiler';
export * from './core/dependency';
export * from './core/templating';
export * from './core/tokenization';
export * from './errors';
export * from './utils';
export * from './types';

================
File: src/interfaces/cli.ts
================
// src/interfaces/cli.ts

import { ICompileOptions } from "@/types/compiler";
import { IService } from "@/types/services";
import { ILogger } from "@/utils/logging/interfaces/ILogger";
import { IConfigManager } from "@/config/interfaces/IConfigManager";
import { ICompileContext } from "@/core/compiler/interfaces/ICompileContext";
import { IArgumentParser } from "@/core/compiler/interfaces/IArgumentParser";
import { IFileSystem } from "@/utils";

export interface ICLIDeps {
  logger: ILogger;
  configManager: IConfigManager;
  compiler: ICompileContext;
  argumentParser: IArgumentParser;
  fileSystem: IFileSystem;
}

export interface ICLIOptions {
  debug?: boolean;
  defaultConfig?: boolean;
  exitOnError?: boolean;
}

export interface ICLIResult {
  success: boolean;
  exitCode: number;
  output?: string;
  error?: Error;
  metrics?: ICLIMetrics;
}

export interface ICLIMetrics {
  executionTime: number;
  memoryUsage: number;
  filesProcessed: number;
  errors: number;
  warnings: number;
}

export interface ICLIProgress {
  phase: string;
  completed: number;
  total: number;
  message?: string;
}

export interface ICLIEventMap {
  "command:start": {
    command: string;
    options: ICompileOptions;
    timestamp: number;
  };
  "command:complete": {
    command: string;
    result: ICLIResult;
    timestamp: number;
  };
  error: {
    error: Error;
    command?: string;
    timestamp: number;
  };
  warning: {
    message: string;
    command?: string;
    timestamp: number;
  };
  progress: ICLIProgress;
}

export interface ICLI extends IService {
  run(): Promise<ICLIResult>;

  on<K extends keyof ICLIEventMap>(
    event: K,
    listener: (data: ICLIEventMap[K]) => void,
  ): this;

  off<K extends keyof ICLIEventMap>(
    event: K,
    listener: (data: ICLIEventMap[K]) => void,
  ): this;

  emit<K extends keyof ICLIEventMap>(event: K, data: ICLIEventMap[K]): boolean;
}

================
File: src/register.ts
================
// src/register.ts
import path from "path";
import moduleAlias from "module-alias";

// Add path aliases
moduleAlias.addAliases({
  "@": path.join(__dirname, "/"),
});

================
File: src/types/common.ts
================
// Basic utility types used throughout the application
export type Optional<T> = T | undefined;
export type Nullable<T> = T | null;
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// Common operation types
export type Operation = "read" | "write" | "create" | "delete" | "update";

// Common result types
export interface IResult<T> {
  success: boolean;
  data?: T;
  error?: string;
}

// Common metadata types
export interface IMetadata {
  createdAt: string;
  updatedAt: string;
  version: string;
}

================
File: src/types/compiler.ts
================
import { IMetadata } from "./common";

export interface ICompileOptions {
  /**
   * Array of entry file paths to analyze
   */
  entryFiles: string[];

  /**
   * Output file path
   */
  outputFile: string;

  /**
   * Project root directory
   */
  rootDir?: string;

  /**
   * Maximum depth for dependency analysis
   */
  maxDepth?: number;

  /**
   * Custom configuration overrides
   */
  config?: Record<string, unknown>;

  /**
   * Whether to collect and include metrics
   */
  includeMetrics?: boolean;

  /**
   * Batch size for processing files
   */
  batchSize?: number;

  /**
   * File encoding
   */
  encoding?: BufferEncoding;

  /**
   * Patterns to ignore
   */
  ignorePatterns?: string[];

  /**
   * Required files to include
   */
  requiredFiles?: string[];

  /**
   * Initialize configuration
   */
  init?: boolean;

  /**
   * Enable debug mode
   */
  debug?: boolean;
}

export interface ICompileResult {
  /**
   * Number of files processed
   */
  filesProcessed: number;

  /**
   * Path to the output file
   */
  outputPath: string;

  /**
   * Total number of tokens in processed files
   */
  totalTokens: number;

  /**
   * Timestamp when the result was generated
   */
  generationTime: string;

  /**
   * Number of required files processed (if any)
   */
  requiredFilesProcessed?: number;

  /**
   * Number of files skipped during processing
   */
  skippedFiles?: number;

  /**
   * Compilation metrics (if enabled)
   */
  metrics?: ICompileMetrics;

  /**
   * Metadata about the compilation
   */
  metadata: IMetadata;
}

export interface ICompilationStats {
  /**
   * Timestamp when compilation started
   */
  startTime: string;

  /**
   * Timestamp when compilation ended
   */
  endTime: string;

  /**
   * Total duration in milliseconds
   */
  duration: number;

  /**
   * Total number of files processed
   */
  totalFiles: number;

  /**
   * Number of files successfully processed
   */
  processedFiles: number;

  /**
   * Number of files skipped
   */
  skippedFiles: number;

  /**
   * Total number of tokens processed
   */
  totalTokens: number;
}

export interface ICompileMetrics {
  /**
   * Number of files processed
   */
  filesProcessed: number;

  /**
   * Total number of tokens processed
   */
  totalTokens: number;

  /**
   * Total processing time in milliseconds
   */
  processingTime: number;

  /**
   * Peak memory usage in bytes
   */
  memoryUsage: number;

  /**
   * Time spent on dependency analysis in milliseconds
   */
  dependencyAnalysisTime: number;

  /**
   * Time spent on tokenization in milliseconds
   */
  tokenizationTime: number;

  /**
   * Time spent on output generation in milliseconds
   */
  outputGenerationTime: number;

  /**
   * Number of errors encountered
   */
  errors: number;

  /**
   * Number of warnings encountered
   */
  warnings: number;
}

================
File: src/types/config.ts
================
import { TiktokenModel } from "./models/tokenizer";
import { DeepPartial } from "./common";

export interface ITokenizerConfig {
  model: TiktokenModel;
  showWarning: boolean;
  contextLimit?: number;
  customProperties?: Record<string, unknown>;
}

export interface IOutputConfig {
  includeSummaryInFile: boolean;
  includeGenerationTime: boolean;
  includeUsageGuidelines: boolean;
  format?: "json" | "text" | "markdown";
}

export interface ICustomText {
  header?: string;
  footer?: string;
  beforeSummary?: string;
  afterSummary?: string;
  beforeFiles?: string;
}

export interface IGatherTSConfig {
  maxDepth?: number;
  topFilesCount: number;
  showTokenCount: boolean;
  tokenizer: ITokenizerConfig;
  outputFormat: IOutputConfig;
  debug?: boolean;
  cacheTokenCounts?: boolean;
  requiredFiles?: string[];
  customText?: ICustomText;
}

export type ConfigOverrides = DeepPartial<IGatherTSConfig>;

export interface IConfigValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

export interface IConfigLoadResult {
  config: IGatherTSConfig;
  source: "file" | "default" | "override";
  validation: IConfigValidationResult;
}

================
File: src/types/dependency.ts
================
/**
 * Represents a map of file dependencies where each key is a file path
 * and the value is an array of paths to its dependencies
 */
export interface IDependencyMap {
  [key: string]: string[];
}

================
File: src/types/errors.ts
================
// types/errors.ts

export interface IBaseError extends Error {
  readonly details?: IErrorDetails;
}

export interface IErrorDetails {
  [key: string]: unknown;
}

export interface IValidationErrorDetails extends IErrorDetails {
  filePath?: string;
  providedValue?: unknown;
  expectedType?: string;
  allowedValues?: unknown[];
}

export interface IFileSystemErrorDetails extends IErrorDetails {
  filePath: string;
  operation: "read" | "write" | "delete" | "create";
}

export interface IConfigurationErrorDetails extends IErrorDetails {
  configPath?: string;
  invalidFields?: string[];
  providedValue?: unknown;
  allowedValues?: unknown[];
}

export interface ITokenizationErrorDetails extends IErrorDetails {
  filePath: string;
  operation: "encode" | "decode" | "initialize" | "cleanup";
  model?: string;
}

export interface IDependencyAnalysisErrorDetails extends IErrorDetails {
  entryPoint?: string;
  failedDependencies?: string[];
}

================
File: src/types/events.ts
================
// src/types/events.ts

import { ICLIOptions, ICLIResult } from "@/interfaces/cli";

/**
 * CLI event map
 */
export interface ICLIEventMap {
  /** Command start event */
  "command:start": {
    command: string;
    options: ICLIOptions;
    timestamp: number;
  };
  /** Command complete event */
  "command:complete": {
    command: string;
    result: ICLIResult;
    timestamp: number;
  };
  /** Error event */
  error: {
    error: Error;
    command?: string;
    timestamp: number;
  };
  /** Warning event */
  warning: {
    message: string;
    command?: string;
    timestamp: number;
  };
  /** Progress event */
  progress: {
    phase: string;
    completed: number;
    total: number;
    message?: string;
  };
}

/**
 * CLI event emitter interface
 */
export interface ICLIEventEmitter {
  on<K extends keyof ICLIEventMap>(
    event: K,
    listener: (data: ICLIEventMap[K]) => void,
  ): void;

  off<K extends keyof ICLIEventMap>(
    event: K,
    listener: (data: ICLIEventMap[K]) => void,
  ): void;

  emit<K extends keyof ICLIEventMap>(event: K, data: ICLIEventMap[K]): void;
}

================
File: src/types/files.ts
================
export interface IFileInfo {
  absolute: string;
  relative: string;
  path: string;
  size?: number;
  extension?: string;
  lastModified?: Date;
}

export interface IFileWithContent extends IFileInfo {
  content: string;
  hash?: string;
}

export interface IFileStats {
  path: string;
  chars: number;
  tokens: number;
  lines?: number;
  size?: number;
}

export interface IProcessedFile extends IFileWithContent {
  stats: IFileStats;
}

export interface IOutputContent {
  header?: string;
  summary?: string;
  fileList: string[];
  fileContents: IFileWithContent[];
  stats?: IFileStats;
  footer?: string;
}

export interface IFileBatch {
  files: IFileInfo[];
  totalSize: number;
  batchNumber: number;
}

export type FileType =
  | "typescript"
  | "javascript"
  | "json"
  | "markdown"
  | "text"
  | "unknown";

export interface IFileTypeInfo {
  type: FileType;
  extension: string;
  binary: boolean;
  processable: boolean;
}

================
File: src/types/index.ts
================
export * from "./compiler";
export * from "./config";
export * from "./dependency";
export * from "./errors";
export * from "./events";
export * from "./files";
export * from "./services";
export * from "./stats";
export * from "./models/tokenizer";

================
File: src/types/models/tokenizer.ts
================
export type TiktokenModel =
  | "gpt-3.5-turbo"
  | "gpt-4"
  | "gpt-4o"
  | "gpt-4o-mini"
  | "o1"
  | "o1-mini"
  | "o3-mini";

export interface IModelConfig {
  name: TiktokenModel;
  contextLimit: number;
  tokenizerConfig?: Record<string, unknown>;
}

export interface ITokenizerOptions {
  model: TiktokenModel;
  customProperties?: Record<string, unknown>;
}

export interface ITokenizationResult {
  tokens: number;
  text: string;
  model: TiktokenModel;
  truncated: boolean;
}

export interface IModelStats {
  modelName: TiktokenModel;
  maxContextLength: number;
  averageTokensPerChar: number;
  supportedFeatures: string[];
}

================
File: src/types/services.ts
================
// src/types/services.ts

import { ICompileOptions, ICompileResult } from "compiler";
import { IGatherTSConfig, IConfigValidationResult } from "config";
import { IFileWithContent } from "files";
import { ISummaryStats } from "stats";

export interface IService {
  isInitialized: boolean;
  initialize(): Promise<void>;
  cleanup(): void;
}

export interface ICompilationService extends IService {
  compile(options: ICompileOptions): Promise<ICompileResult>;
  validateOptions(options: ICompileOptions): Promise<boolean>;
}

export interface ITokenizationService extends IService {
  countTokens(filePath: string, text: string): Promise<number>;
  generateSummary(filesWithContent: IFileWithContent[]): Promise<ISummaryStats>;
  generateSummaryText(stats: ISummaryStats): string;
  printSummary(stats: ISummaryStats, outputFile: string): void;
}

export interface IConfigurationService extends IService {
  validateConfig(config: Partial<IGatherTSConfig>): IConfigValidationResult;
  loadConfig(configPath: string): Promise<IGatherTSConfig>;
  saveConfig(config: IGatherTSConfig, configPath: string): Promise<void>;
  getDefaultConfig(): IGatherTSConfig;
}

export interface IDependencyService extends IService {
  analyzeDependencies(
    entryFile: string,
    projectRoot: string,
  ): Promise<string[]>;
  validateEntryPoints(entryFiles: string[]): Promise<boolean>;
  getDependencyGraph(): Promise<Map<string, string[]>>;
}

export interface ICacheService extends IService {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T, ttl?: number): Promise<void>;
  delete(key: string): Promise<void>;
  clear(): Promise<void>;
  has(key: string): Promise<boolean>;
}

// src/types/services.ts

export abstract class BaseService implements IService {
  isInitialized: boolean = false;

  public async initialize(): Promise<void> {
    this.isInitialized = true;
  }

  public cleanup(): void {
    this.isInitialized = false;
  }

  protected checkInitialized(): void {
    if (!this.isInitialized) {
      throw new Error(`${this.constructor.name} not initialized`);
    }
  }
}

================
File: src/types/stats.ts
================
import { IFileStats } from "./files";

export interface ISummaryStats {
  totalFiles: number;
  totalChars: number;
  totalTokens: number;
  topFiles: IFileStats[];
  generationTime: string;
  averageTokensPerFile?: number;
  maxTokensInFile?: number;
  minTokensInFile?: number;
  tokenDistribution?: ITokenDistribution;
}

export interface ITokenDistribution {
  ranges: ITokenRange[];
  average: number;
  median: number;
  standardDeviation: number;
}

export interface ITokenRange {
  min: number;
  max: number;
  count: number;
  percentage: number;
}

export interface IProcessingStats {
  processedFiles: number;
  skippedFiles: number;
  errorFiles: number;
  totalProcessingTime: number;
  averageProcessingTime: number;
}

export interface IPerformanceMetrics {
  tokenizationTime: number;
  compressionRatio: number;
  memoryUsage: number;
  processingSpeed: number; // files per second
}

================
File: src/utils/filesystem/FileSystem.ts
================
// src/utils/filesystem/FileSystem.ts

import fs from "fs";
import path from "path";
import { FileSystemError, ValidationError } from "@/errors";
import {
  IFileSystem,
  IFileSystemOptions,
  IFileSystemDeps,
  IFileOperationOptions,
} from "./interfaces/IFileSystem";
import { BaseService } from "@/types/services";

export class FileSystem extends BaseService implements IFileSystem {
  private readonly debug: boolean;

  constructor(
    private readonly deps: IFileSystemDeps,
    options: IFileSystemOptions = {},
  ) {
    super();
    this.debug = options.debug || false;
  }

  public override async initialize(): Promise<void> {
    await super.initialize();
    this.logDebug("FileSystem service initialized");
  }

  public override cleanup(): void {
    this.logDebug("FileSystem service cleanup");
    super.cleanup();
  }

  private logDebug(message: string): void {
    if (this.debug) {
      this.deps.logger.debug(message);
    }
  }

  private handleError(
    error: unknown,
    operation: string,
    filePath: string,
  ): never {
    const message = error instanceof Error ? error.message : String(error);
    const fsError = new FileSystemError(
      `Failed to ${operation} file: ${message}`,
      filePath,
      operation as "read" | "write" | "delete" | "create",
    );
    this.deps.logger.error(fsError.message);
    throw fsError;
  }

  public statSync(path: string): { mtime: Date } {
    try {
      const stats = fs.statSync(path);
      return {
        mtime: stats.mtime,
      };
    } catch (error) {
      this.handleError(error, "stat", path);
    }
  }

  public readFileSync(
    filePath: string,
    encoding: BufferEncoding = "utf8",
  ): string {
    this.checkInitialized();
    this.logDebug(`Reading file synchronously: ${filePath}`);
    try {
      return fs.readFileSync(filePath, encoding);
    } catch (error) {
      this.handleError(error, "read", filePath);
    }
  }

  public writeFileSync(
    filePath: string,
    data: string | Buffer,
    options?: IFileOperationOptions,
  ): void {
    this.logDebug(`Writing file synchronously: ${filePath}`);
    try {
      const dir = this.getDirName(filePath);
      if (!this.exists(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      fs.writeFileSync(filePath, data, options);
    } catch (error) {
      this.handleError(error, "write", filePath);
    }
  }

  public exists(path: string): boolean {
    return fs.existsSync(path);
  }

  public isReadable(filePath: string): boolean {
    try {
      fs.accessSync(filePath, fs.constants.R_OK);
      return true;
    } catch {
      return false;
    }
  }

  public isWritable(filePath: string): boolean {
    try {
      fs.accessSync(filePath, fs.constants.W_OK);
      return true;
    } catch {
      return false;
    }
  }

  public async readFile(
    filePath: string,
    options?: IFileOperationOptions,
  ): Promise<string> {
    this.logDebug(`Reading file: ${filePath}`);
    try {
      const buffer = await fs.promises.readFile(filePath, options);
      return buffer.toString(options?.encoding || "utf8");
    } catch (error) {
      this.handleError(error, "read", filePath);
    }
  }

  public async writeFile(
    filePath: string,
    data: string | Buffer,
    options?: IFileOperationOptions,
  ): Promise<void> {
    this.logDebug(`Writing file: ${filePath}`);
    try {
      const dir = this.getDirName(filePath);
      await fs.promises.mkdir(dir, { recursive: true });
      await fs.promises.writeFile(filePath, data, options);
    } catch (error) {
      this.handleError(error, "write", filePath);
    }
  }

  public async deleteFile(filePath: string): Promise<void> {
    this.logDebug(`Deleting file: ${filePath}`);
    try {
      await fs.promises.unlink(filePath);
    } catch (error) {
      this.handleError(error, "delete", filePath);
    }
  }

  public async createDirectory(
    dirPath: string,
    recursive: boolean = true,
  ): Promise<void> {
    this.logDebug(`Creating directory: ${dirPath}`);
    try {
      await fs.promises.mkdir(dirPath, { recursive });
    } catch (error) {
      this.handleError(error, "create", dirPath);
    }
  }

  public resolvePath(...paths: string[]): string {
    return path.resolve(...paths);
  }

  public joinPath(...paths: string[]): string {
    return path.join(...paths);
  }

  public getRelativePath(from: string, to: string): string {
    return path.relative(from, to);
  }

  public getDirName(filePath: string): string {
    return path.dirname(filePath);
  }

  public getBaseName(filePath: string): string {
    return path.basename(filePath);
  }

  public getExtension(filePath: string): string {
    return path.extname(filePath);
  }

  public isAbsolute(filePath: string): boolean {
    return path.isAbsolute(filePath);
  }

  // Alternative method names that do the same thing
  public dirname(filePath: string): string {
    return this.getDirName(filePath);
  }

  public basename(filePath: string): string {
    return this.getBaseName(filePath);
  }

  public extname(filePath: string): string {
    return this.getExtension(filePath);
  }

  public validatePath(filePath: string, checkExists: boolean = true): void {
    if (!filePath) {
      const err = new ValidationError("Empty file path provided");
      this.deps.logger.error(err.message);
      throw err;
    }

    if (checkExists && !this.exists(filePath)) {
      const err = new ValidationError("File does not exist", { filePath });
      this.deps.logger.error(err.message);
      throw err;
    }
  }
}

================
File: src/utils/filesystem/index.ts
================
// src/utils/filesystem/index.ts
export * from "./FileSystem";
export * from "./interfaces/IFileSystem";

================
File: src/utils/filesystem/interfaces/IFileSystem.ts
================
// src/utils/filesystem/interfaces/IFileSystem.ts

import { IService } from "@/types/services";
import { ILogger } from "@/utils/logging/interfaces/ILogger";

export interface IFileOperationOptions {
  encoding?: BufferEncoding;
  flag?: string;
}

export interface IFileSystemOptions {
  debug?: boolean;
}

export interface IFileSystemDeps {
  logger: ILogger;
}

export interface IFileSystem extends IService {
  // Path operations
  resolvePath(...paths: string[]): string;
  joinPath(...paths: string[]): string;
  getRelativePath(from: string, to: string): string;
  getDirName(path: string): string;
  getBaseName(path: string): string;
  getExtension(path: string): string;
  isAbsolute(path: string): boolean;

  // Alternative path operation names
  dirname(path: string): string;
  basename(path: string): string;
  extname(path: string): string;

  // Synchronous operations
  statSync(path: string): {
    mtime: Date;
  };
  readFileSync(filePath: string, encoding?: BufferEncoding): string;
  writeFileSync(
    filePath: string,
    data: string | Buffer,
    options?: IFileOperationOptions,
  ): void;
  exists(path: string): boolean;
  isReadable(filePath: string): boolean;
  isWritable(filePath: string): boolean;

  // Asynchronous operations
  readFile(filePath: string, options?: IFileOperationOptions): Promise<string>;
  writeFile(
    filePath: string,
    data: string | Buffer,
    options?: IFileOperationOptions,
  ): Promise<void>;
  deleteFile(filePath: string): Promise<void>;
  createDirectory(dirPath: string, recursive?: boolean): Promise<void>;

  // Validation
  validatePath(filePath: string, checkExists?: boolean): void;
}

================
File: src/utils/index.ts
================
export * from "./logging";
export * from "./filesystem";
export * from "./validation";

================
File: src/utils/logging/index.ts
================
// src/utils/logging/index.ts

export * from "./Logger";
export * from "./interfaces/ILogger";

================
File: src/utils/logging/interfaces/ILogger.ts
================
// src/utils/logging/interfaces/ILogger.ts

import { IService } from "@/types/services";

export interface ILogColors {
  reset: string;
  bright: string;
  dim: string;
  blue: string;
  green: string;
  yellow: string;
  red: string;
  gray: string;
}

export type LogLevel = "debug" | "info" | "warn" | "error";

export interface ILoggerOptions {
  /** Enable debug mode */
  enableDebug?: boolean;
  /** Custom colors */
  colors?: Partial<ILogColors>;
  /** Include timestamps */
  timestamp?: boolean;
  /** Minimum log level */
  logLevel?: LogLevel;
}

export interface ILoggerDeps {
  outputStream: NodeJS.WriteStream;
  errorStream: NodeJS.WriteStream;
}

export interface ILogger extends IService {
  /** Log informational message */
  info(message: string): void;

  /** Log success message */
  success(message: string): void;

  /** Log warning message */
  warn(message: string): void;

  /** Log error message */
  error(message: string): void;

  /** Log debug message */
  debug(message: string): void;

  /** Log section header */
  section(title: string): void;

  /** Log summary with stats */
  summary(title: string, stats: Record<string, any>): void;

  /** Enable debug logging */
  enableDebug(): void;

  /** Check if debug is enabled */
  isDebugEnabled(): boolean;
}

================
File: src/utils/logging/Logger.ts
================
// src/utils/logging/Logger.ts

import { BaseService } from "@/types/services";
import {
  ILogger,
  ILoggerOptions,
  ILoggerDeps,
  ILogColors,
  LogLevel,
} from "./interfaces/ILogger";

export class Logger extends BaseService implements ILogger {
  private readonly colors: ILogColors;
  private readonly timestamp: boolean;
  private readonly logLevel: LogLevel;
  private debugEnabled: boolean;

  constructor(
    private readonly deps: ILoggerDeps,
    options: ILoggerOptions = {},
  ) {
    super();
    this.colors = {
      reset: "\x1b[0m",
      bright: "\x1b[1m",
      dim: "\x1b[2m",
      blue: "\x1b[34m",
      green: "\x1b[32m",
      yellow: "\x1b[33m",
      red: "\x1b[31m",
      gray: "\x1b[90m",
      ...options.colors,
    };
    this.debugEnabled = options.enableDebug || false;
    this.timestamp = options.timestamp || false;
    this.logLevel = options.logLevel || "info";
  }

  public override async initialize(): Promise<void> {
    await super.initialize();
    if (this.debugEnabled) {
      this.debug("Logger initialized");
    }
  }

  public override cleanup(): void {
    if (this.debugEnabled) {
      this.debug("Logger cleanup");
    }
    super.cleanup();
  }

  private format(color: keyof ILogColors, message: string): string {
    return `${this.colors[color]}${message}${this.colors.reset}`;
  }

  private formatWithTimestamp(message: string): string {
    if (!this.timestamp) return message;
    const timestamp = new Date().toISOString();
    return `[${timestamp}] ${message}`;
  }

  private shouldLog(level: LogLevel): boolean {
    const levels: LogLevel[] = ["debug", "info", "warn", "error"];
    const currentLevel = levels.indexOf(this.logLevel);
    const messageLevel = levels.indexOf(level);
    return messageLevel >= currentLevel;
  }

  public info(message: string): void {
    if (!this.shouldLog("info")) return;
    const formattedMessage = this.formatWithTimestamp(
      this.format("blue", "‚Ñπ") + " " + message,
    );
    this.deps.outputStream.write(formattedMessage + "\n");
  }

  public success(message: string): void {
    if (!this.shouldLog("info")) return;
    const formattedMessage = this.formatWithTimestamp(
      this.format("green", "‚úì") + " " + message,
    );
    this.deps.outputStream.write(formattedMessage + "\n");
  }

  public warn(message: string): void {
    if (!this.shouldLog("warn")) return;
    const formattedMessage = this.formatWithTimestamp(
      this.format("yellow", "‚ö†") + " " + message,
    );
    this.deps.outputStream.write(formattedMessage + "\n");
  }

  public error(message: string): void {
    if (!this.shouldLog("error")) return;
    const formattedMessage = this.formatWithTimestamp(
      this.format("red", "‚úñ") + " " + message,
    );
    this.deps.errorStream.write(formattedMessage + "\n");
  }

  public debug(message: string): void {
    if (!this.debugEnabled || !this.shouldLog("debug")) return;
    const formattedMessage = this.formatWithTimestamp(
      this.format("gray", "‚Üí") + " " + message,
    );
    this.deps.outputStream.write(formattedMessage + "\n");
  }

  public section(title: string): void {
    if (!this.shouldLog("info")) return;
    this.deps.outputStream.write("\n" + this.format("bright", title) + "\n");
    this.deps.outputStream.write(
      this.format("dim", "‚îÄ".repeat(title.length)) + "\n",
    );
  }

  public summary(title: string, stats: Record<string, any>): void {
    if (!this.shouldLog("info")) return;
    this.section(title);
    Object.entries(stats).forEach(([key, value]) => {
      this.deps.outputStream.write(
        this.format("gray", `${key.padStart(15)}: `) +
          this.format("bright", String(value)) +
          "\n",
      );
    });
  }

  public enableDebug(): void {
    this.debugEnabled = true;
  }

  public isDebugEnabled(): boolean {
    return this.debugEnabled;
  }
}

================
File: src/utils/validation/index.ts
================
// src/utils/validation/index.ts
export * from "./Validator";
export * from "./interfaces/IValidator";

================
File: src/utils/validation/interfaces/IValidator.ts
================
// src/utils/validation/interfaces/IValidator.ts

import { IService } from "@/types/services";
import { ILogger } from "@/utils/logging/interfaces/ILogger";

export interface IValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

export interface IValidationOptions {
  optional?: boolean;
  allowEmpty?: boolean;
  type?: string;
  minLength?: number;
  maxLength?: number;
  min?: number;
  max?: number;
  integer?: boolean;
  pattern?: RegExp;
  arrayType?: string;
  requiredFields?: string[];
  customValidator?: (value: any) => boolean;
}

export interface IValidatorDeps {
  logger: ILogger;
}

export interface IValidatorOptions {
  debug?: boolean;
}

export interface ITypeValidator {
  isString(value: unknown): value is string;
  isNumber(value: unknown): value is number;
  isBoolean(value: unknown): value is boolean;
  isObject(value: unknown): value is object;
  isArray(value: unknown): value is unknown[];
  isDate(value: unknown): value is Date;
}

export interface IValidator extends IService, ITypeValidator {
  validate<T>(
    value: unknown,
    fieldName: string,
    options?: IValidationOptions,
  ): IValidationResult;
  validateNotEmpty<T>(value: T | null | undefined, fieldName: string): T;
  validateType(value: unknown, expectedType: string, fieldName: string): void;
  validateRange(
    value: number,
    min: number,
    max: number,
    fieldName: string,
  ): void;
  validateEnum<T extends string>(
    value: string,
    enumValues: readonly T[],
    fieldName: string,
  ): T;
  validatePattern(value: string, pattern: RegExp, fieldName: string): void;
  validatePath(path: string, context: string): void;
}

================
File: src/utils/validation/Validator.ts
================
// src/utils/validation/Validator.ts

import { ValidationError } from "@/errors";
import {
  IValidator,
  IValidatorDeps,
  IValidationOptions,
  IValidationResult,
  ITypeValidator,
  IValidatorOptions,
} from "./interfaces/IValidator";
import { BaseService } from "@/types/services";

export class Validator
  extends BaseService
  implements IValidator, ITypeValidator
{
  private readonly debug: boolean;

  constructor(
    private readonly deps: IValidatorDeps,
    options: IValidatorOptions = {},
  ) {
    super();
    this.debug = options.debug || false;
  }

  public override async initialize(): Promise<void> {
    await super.initialize();
    this.logDebug("Validator service initialized");
  }

  public override cleanup(): void {
    this.logDebug("Validator service cleanup");
    super.cleanup();
  }

  private logDebug(message: string): void {
    if (this.debug) {
      this.deps.logger.debug(message);
    }
  }

  private handleValidationError(
    fieldName: string,
    message: string,
    details?: Record<string, unknown>,
  ): never {
    const error = new ValidationError(message, details);
    this.deps.logger.error(`Validation error for ${fieldName}: ${message}`);
    throw error;
  }

  public validate<T>(
    value: unknown,
    fieldName: string,
    options: IValidationOptions = {},
  ): IValidationResult {
    this.checkInitialized();
    this.logDebug(`Validating ${fieldName}`);

    const result: IValidationResult = {
      isValid: true,
      errors: [],
      warnings: [],
    };

    try {
      // Handle optional fields
      if (value === undefined || value === null) {
        if (!options.optional) {
          result.errors.push(`${fieldName} is required`);
          result.isValid = false;
        }
        return result;
      }

      // Type validation
      if (options.type && typeof value !== options.type) {
        result.errors.push(
          `${fieldName} must be of type ${options.type}, got ${typeof value}`,
        );
        result.isValid = false;
        return result;
      }

      // Type-specific validations
      if (typeof value === "string") {
        this.validateString(value, fieldName, options, result);
      }
      if (typeof value === "number") {
        this.validateNumber(value, fieldName, options, result);
      }
      if (Array.isArray(value)) {
        this.validateArray(value, fieldName, options, result);
      }
      if (this.isObject(value)) {
        this.validateObject(value, fieldName, options, result);
      }

      // Custom validation
      if (options.customValidator) {
        this.runCustomValidator(
          value,
          fieldName,
          options.customValidator,
          result,
        );
      }
    } catch (error) {
      result.errors.push(
        error instanceof Error ? error.message : String(error),
      );
      result.isValid = false;
      this.deps.logger.error(
        `Validation error for ${fieldName}: ${error instanceof Error ? error.message : String(error)}`,
      );
    }

    this.logDebug(
      `Validation result for ${fieldName}: ${result.isValid ? "valid" : "invalid"}`,
    );
    return result;
  }

  private validateString(
    value: string,
    fieldName: string,
    options: IValidationOptions,
    result: IValidationResult,
  ): void {
    if (!options.allowEmpty && value.trim() === "") {
      result.errors.push(`${fieldName} cannot be empty`);
      result.isValid = false;
      return;
    }

    if (options.minLength !== undefined && value.length < options.minLength) {
      result.errors.push(
        `${fieldName} must be at least ${options.minLength} characters long`,
      );
      result.isValid = false;
    }

    if (options.maxLength !== undefined && value.length > options.maxLength) {
      result.errors.push(
        `${fieldName} cannot exceed ${options.maxLength} characters`,
      );
      result.isValid = false;
    }

    if (options.pattern && !options.pattern.test(value)) {
      result.errors.push(`${fieldName} has an invalid format`);
      result.isValid = false;
    }
  }

  private validateNumber(
    value: number,
    fieldName: string,
    options: IValidationOptions,
    result: IValidationResult,
  ): void {
    if (options.min !== undefined && value < options.min) {
      result.errors.push(`${fieldName} must be at least ${options.min}`);
      result.isValid = false;
    }

    if (options.max !== undefined && value > options.max) {
      result.errors.push(`${fieldName} cannot exceed ${options.max}`);
      result.isValid = false;
    }

    if (options.integer && !Number.isInteger(value)) {
      result.errors.push(`${fieldName} must be an integer`);
      result.isValid = false;
    }
  }

  private validateArray(
    value: unknown[],
    fieldName: string,
    options: IValidationOptions,
    result: IValidationResult,
  ): void {
    if (options.minLength !== undefined && value.length < options.minLength) {
      result.errors.push(
        `${fieldName} must contain at least ${options.minLength} items`,
      );
      result.isValid = false;
    }

    if (options.maxLength !== undefined && value.length > options.maxLength) {
      result.errors.push(
        `${fieldName} cannot contain more than ${options.maxLength} items`,
      );
      result.isValid = false;
    }

    if (options.arrayType) {
      const invalidItems = value.filter(
        item => typeof item !== options.arrayType,
      );
      if (invalidItems.length > 0) {
        result.errors.push(
          `All items in ${fieldName} must be of type ${options.arrayType}`,
        );
        result.isValid = false;
      }
    }
  }

  private validateObject(
    value: object,
    fieldName: string,
    options: IValidationOptions,
    result: IValidationResult,
  ): void {
    if (options.requiredFields) {
      const missingFields = options.requiredFields.filter(
        field => !(field in value),
      );
      if (missingFields.length > 0) {
        result.errors.push(
          `${fieldName} is missing required fields: ${missingFields.join(", ")}`,
        );
        result.isValid = false;
      }
    }
  }

  public validatePath(path: string, context: string): void {
    if (!path || typeof path !== "string") {
      throw new ValidationError(`Invalid ${context} path`, { path });
    }

    // Check for invalid characters in path
    const invalidChars = /[<>:"|?*]/g;
    if (invalidChars.test(path)) {
      throw new ValidationError(`${context} path contains invalid characters`, {
        path,
        invalidChars: '<>:"|?*',
      });
    }

    // Check for relative path navigation
    if (path.includes("../") || path.includes("..\\")) {
      throw new ValidationError(
        `${context} path cannot contain relative navigation`,
        { path },
      );
    }

    // Log debug info
    this.logDebug(`Validated path for ${context}: ${path}`);
  }

  private runCustomValidator(
    value: unknown,
    fieldName: string,
    validator: (value: unknown) => boolean,
    result: IValidationResult,
  ): void {
    try {
      const customResult = validator(value);
      if (!customResult) {
        result.errors.push(`${fieldName} failed custom validation`);
        result.isValid = false;
      }
    } catch (error) {
      result.errors.push(
        `Custom validation error for ${fieldName}: ${error instanceof Error ? error.message : String(error)}`,
      );
      result.isValid = false;
    }
  }

  // Type Guard Implementations
  public isString(value: unknown): value is string {
    return typeof value === "string";
  }

  public isNumber(value: unknown): value is number {
    return typeof value === "number" && !isNaN(value);
  }

  public isBoolean(value: unknown): value is boolean {
    return typeof value === "boolean";
  }

  public isObject(value: unknown): value is object {
    return typeof value === "object" && value !== null && !Array.isArray(value);
  }

  public isArray(value: unknown): value is unknown[] {
    return Array.isArray(value);
  }

  public isDate(value: unknown): value is Date {
    return value instanceof Date && !isNaN(value.getTime());
  }

  // Helper Methods
  public validateNotEmpty<T>(
    value: T | null | undefined,
    fieldName: string,
  ): T {
    const result = this.validate(value, fieldName, { optional: false });
    if (!result.isValid) {
      this.handleValidationError(fieldName, result.errors[0]);
    }
    return value as T;
  }

  public validateType(
    value: unknown,
    expectedType: string,
    fieldName: string,
  ): void {
    const result = this.validate(value, fieldName, { type: expectedType });
    if (!result.isValid) {
      this.handleValidationError(fieldName, result.errors[0]);
    }
  }

  public validateRange(
    value: number,
    min: number,
    max: number,
    fieldName: string,
  ): void {
    const result = this.validate(value, fieldName, {
      type: "number",
      min,
      max,
    });
    if (!result.isValid) {
      this.handleValidationError(fieldName, result.errors[0]);
    }
  }

  public validateEnum<T extends string>(
    value: string,
    enumValues: readonly T[],
    fieldName: string,
  ): T {
    const result = this.validate(value, fieldName, {
      type: "string",
      customValidator: val => enumValues.includes(val as T),
    });
    if (!result.isValid) {
      this.handleValidationError(
        fieldName,
        `${fieldName} must be one of: ${enumValues.join(", ")}`,
        { value, allowedValues: enumValues },
      );
    }
    return value as T;
  }

  public validatePattern(
    value: string,
    pattern: RegExp,
    fieldName: string,
  ): void {
    const result = this.validate(value, fieldName, {
      type: "string",
      pattern,
    });
    if (!result.isValid) {
      this.handleValidationError(fieldName, result.errors[0]);
    }
  }
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./",
    "strict": true,
    "moduleResolution": "node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "sourceMap": true,
    "allowJs": false,
    "resolveJsonModule": true,
    "baseUrl": ".",
    "paths": {
      "*": ["node_modules/*", "src/types/*"],
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "src/**/*",
  ],
  "exclude": [
    "node_modules",
    "dist",
    "**/*.test.ts"
  ]
}

================
File: typedoc.json
================
{
    "$schema": "https://typedoc.org/schema.json",
    "entryPoints": [
      "./src/index.ts",
      "./src/cli.ts",
      "./src/config/**/*.ts",
      "./src/core/**/*.ts",
      "./src/errors/**/*.ts",
      "./src/utils/**/*.ts"
    ],
    "entryPointStrategy": "expand",
    "out": "docs",
    "name": "Gather-ts Documentation",
    "excludePrivate": true,
    "excludeProtected": true,
    "excludeExternals": true,
    "includeVersion": true,
    "categorizeByGroup": true,
    "categoryOrder": ["Core", "Utilities", "Interfaces", "*"],
    "searchInComments": true,
    "plugin": ["typedoc-plugin-markdown"],
    "readme": "README.md",
    "exclude": [
      "**/node_modules/**",
      "**/*.spec.ts",
      "**/*.test.ts",
      "**/dist/**"
    ],
    "theme": "default",
    "cleanOutputDir": true,
    "githubPages": false
  }
