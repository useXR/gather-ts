import path from "path";
import fs from "fs/promises";
import { logger } from "@/utils/logging";
import { IIgnoreHandler } from "@/core/dependency/interfaces/IIgnoreHandler";
import { ITokenCounter } from "@/core/tokenization/interfaces/ITokenCounter";
import { IConfigManager } from "@/config/interfaces/IConfigManager";
import {
  ICompileContext,
  IOutputOptions
} from "./interfaces/ICompileContext";
import {
  ICompileOptions,
  ICompileResult,
} from "@/types/compiler";
import { IFileInfo, IFileWithContent } from "@/types/files";
import { ISummaryStats } from "@/types/stats";
import {
  DependencyAnalysisError,
  ErrorHandler,
  FileSystemError,
  IErrorHandler,
  ValidationError,
} from "@/errors";
import { fileSystem } from "@/utils/filesystem/FileSystem";
import { DependencyAnalyzer } from "../dependency/DependencyAnalyzer";
import { IDependencyAnalyzer } from "../dependency/interfaces/IDependencyAnalyzer";

export class DefaultCompileContext implements ICompileContext {
  private readonly ignoreHandler: IIgnoreHandler;
  private readonly configManager: IConfigManager;
  private readonly tokenCounter: ITokenCounter;
  private readonly errorHandler: IErrorHandler;
  private readonly dependencyAnalyzer: IDependencyAnalyzer;
  private readonly projectRoot: string;

  constructor(
    configHandler: IConfigManager,
    ignoreHandler: IIgnoreHandler,
    tokenCounter: ITokenCounter,
    errorHandler: IErrorHandler
  ) {
    this.configManager = configHandler;
    this.ignoreHandler = ignoreHandler;
    this.tokenCounter = tokenCounter;
    this.errorHandler = errorHandler;
    this.projectRoot = configHandler.getProjectRoot();
    this.dependencyAnalyzer = new DependencyAnalyzer(ignoreHandler, fileSystem);
  }

  async processRequiredFiles(
    relativeFiles: IFileInfo[],
    rootDir: string
  ): Promise<IFileInfo[]> {
    const config = this.configManager.getConfig();
    const processedFiles = [...relativeFiles];

    if (config.requiredFiles?.length) {
      logger.info("Processing required files from config...");
      for (const requiredFile of config.requiredFiles) {
        const absolutePath = path.resolve(rootDir, requiredFile);
        if (!processedFiles.some((f) => f.absolute === absolutePath)) {
          if (fileSystem.exists(absolutePath)) {
            processedFiles.push({
              absolute: absolutePath,
              relative: path.relative(rootDir, absolutePath),
              path: path.relative(rootDir, absolutePath)
            });
            logger.debug(`Added required file: ${requiredFile}`);
          } else {
            logger.warn(`Required file not found: ${requiredFile}`);
          }
        }
      }
    }

    return processedFiles;
  }

  async generateOutput(
    filesWithContent: IFileWithContent[],
    configHandler: IConfigManager,
    maxDepth?: number
  ): Promise<string> {
    const generationTime = new Date().toISOString();
    const config = configHandler.getConfig();
    const customText = config.customText || {};
    const outputFormat = config.outputFormat;

    let output = customText.header ? customText.header + "\n\n" : "";

    // Basic file information
    output += [
      "This file is a merged representation of the entire codebase, combining all repository files into a single document.",
      `Generated by Deppack on: ${generationTime}`,
      "",
      "================================================================",
      "File Summary",
      "================================================================",
      "",
    ].join("\n");

    // Add purpose and format sections
    if (outputFormat.includeUsageGuidelines) {
      output += [
        "Purpose:",
        "--------",
        "This file contains a packed representation of the entire repository's contents.",
        "It is designed to be easily consumable by AI systems for analysis, code review,",
        "or other automated processes.",
        "",
        "File Format:",
        "------------",
        "The content is organized as follows:",
        "1. This summary section",
        "2. Repository information",
        "3. Repository structure",
        "4. Multiple file entries, each consisting of:",
        "  a. A separator line (================)",
        "  b. The file path (File: path/to/file)",
        "  c. Another separator line",
        "  d. The full contents of the file",
        "  e. A blank line",
        "",
        "Usage Guidelines:",
        "-----------------",
        "- This file should be treated as read-only. Any changes should be made to the",
        "  original repository files, not this packed version.",
        "- When processing this file, use the file path to distinguish",
        "  between different files in the repository.",
        "- Be aware that this file may contain sensitive information. Handle it with",
        "  the same level of security as you would the original repository.",
        "",
        "Notes:",
        "------",
        "- Some files may have been excluded based on .gitignore rules and Deppack's",
        "  configuration.",
        "- Binary files are not included in this packed representation. Please refer to",
        "  the Repository Structure section for a complete list of file paths, including",
        "  binary files.",
        "",
        "Additional Info:",
        "----------------",
        "",
      ].join("\n");
    }

    if (customText.beforeSummary) {
      output += customText.beforeSummary + "\n\n";
    }

    // Repository structure
    output += [
      "================================================================",
      "Repository Structure",
      "================================================================",
      ...filesWithContent.map((f) => f.path),
      "",
      "================================================================",
      "Repository Files",
      "================================================================",
      "",
    ].join("\n");

    if (customText.beforeFiles) {
      output += customText.beforeFiles + "\n\n";
    }

    // Add file contents
    for (const { path: filePath, content } of filesWithContent) {
      output += [
        "================",
        `File: ${filePath}`,
        "================",
        content,
        "",
      ].join("\n");
    }

    if (customText.afterSummary) {
      output += "\n" + customText.afterSummary;
    }

    if (customText.footer) {
      output += "\n" + customText.footer;
    }

    return output;
  }

  public generateSummary(
    files: IFileWithContent[],
    stats: ISummaryStats,
    options: IOutputOptions
  ): string {
    const summary: string[] = [];

    if (options.includeGenerationTime) {
      summary.push(`Generated on: ${new Date().toISOString()}\n`);
    }

    if (options.includeStats) {
      summary.push(
        "Summary Statistics:",
        "-----------------",
        `Total Files: ${stats.totalFiles}`,
        `Total Characters: ${stats.totalChars.toLocaleString()}`,
        `Total Tokens: ${stats.totalTokens.toLocaleString()}\n`,
        "Top Files by Size:",
        "----------------"
      );

      stats.topFiles.forEach((file, index) => {
        summary.push(
          `${index + 1}. ${file.path}`,
          `   ${file.chars.toLocaleString()} characters, ${file.tokens.toLocaleString()} tokens`
        );
      });
      summary.push("");
    }

    return summary.join("\n");
  }

  public async compile(options: ICompileOptions): Promise<ICompileResult> {
    try {
      const rootDir = options.rootDir || this.projectRoot;
      logger.info(`Project root: ${rootDir}`);

      // Validate and process entry files using DependencyAnalyzer
      const entryFiles = await this.dependencyAnalyzer.validateEntryFiles(
        options.entryFiles,
        rootDir
      );

      // Analyze dependencies using DependencyAnalyzer
      logger.info("Analyzing dependencies...");
      const deps = await this.dependencyAnalyzer.analyzeDependencies(entryFiles, rootDir);

      // Gather dependencies
      logger.info(`Gathering dependencies (depth: ${options.maxDepth ?? "âˆž"})...`);
      const relevantFiles = await this.dependencyAnalyzer.gatherDependencies(
        deps,
        entryFiles,
        options.maxDepth
      );

      const relativeFiles = relevantFiles
        .map((file) => ({
          absolute: file,
          relative: path.relative(rootDir, file),
          path: path.relative(rootDir, file)
        }))
        .sort((a, b) => a.relative.localeCompare(b.relative));

      // Process required files
      const processedFiles = await this.processRequiredFiles(relativeFiles, rootDir);
      logger.info(`Found ${processedFiles.length} relevant files`);

      // Process files and generate output
      const filesWithContent = await Promise.all(
        processedFiles.map(async (file) => {
          try {
            const content = await fs.readFile(file.absolute, { encoding: "utf8" });
            return {
              absolute: file.absolute,
              relative: file.relative,
              path: file.path,
              content
            };
          } catch (error) {
            throw new FileSystemError(
              `Failed to read file: ${error instanceof Error ? error.message : String(error)}`,
              file.absolute,
              "read"
            );
          }
        })
      );

      // Ensure output directory exists
      const outputDir = path.dirname(options.outputFile);
      await fs.mkdir(outputDir, { recursive: true }).catch(() => {});

      logger.info("Generating output file...");
      const output = await this.generateOutput(
        filesWithContent,
        this.configManager,
        options.maxDepth
      );

      try {
        await fs.writeFile(options.outputFile, output, { encoding: "utf8" });
      } catch (error) {
        throw new FileSystemError(
          `Failed to write output file: ${error instanceof Error ? error.message : String(error)}`,
          options.outputFile,
          "write"
        );
      }

      // Generate token summary if enabled
      let totalTokens = 0;
      if (this.configManager.shouldShowTokenCount()) {
        const stats = await this.tokenCounter.generateSummary(filesWithContent);
        this.tokenCounter.printSummary(stats, options.outputFile);
        totalTokens = stats.totalTokens;
      }

      return {
        filesProcessed: filesWithContent.length,
        outputPath: options.outputFile,
        totalTokens,
        generationTime: new Date().toISOString(),
        metadata: {
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          version: '1.0.0'
        }
      };
    } catch (error) {
      this.errorHandler.handle(
        error instanceof Error ? error : new Error(String(error))
      );
      throw error;
    } finally {
      this.tokenCounter.cleanup();
    }
  }
}